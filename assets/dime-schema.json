{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "DIME Configuration",
  "description": "Schema for DIME configuration files",
  "type": "object",
  "properties": {
    "app": {
      "type": "object",
      "description": "Application-level configuration",
      "properties": {
        "license": {
          "type": "string",
          "description": "Application license key",
          "default": "DEMO-0000-0000-0000-0000-0000-0000-0000"
        },
        "ring_buffer": {
          "type": "integer",
          "description": "Message buffer size between sources and sinks",
          "default": 4096,
          "enum": [ 2048, 4096, 8192 ]
        },
        "http_server_uri": {
          "type": "string",
          "description": "Status server HTTP endpoint",
          "default": "http://127.0.0.1:9999/"
        },
        "ws_server_uri": {
          "type": "string",
          "description": "Status server WebSocket endpoint",
          "default": "ws://127.0.0.1:9998/"
        }
      },
      "required": ["license", "ring_buffer", "http_server_uri", "ws_server_uri"],
      "examples": [
        {
          "license": "ABCD-1234-EFGH-5678-IJKL-9012-MNOP-3456",
          "ring_buffer": 4096,
          "http_server_uri": "http://127.0.0.1:9999/",
          "ws_server_uri": "ws://127.0.0.1:9998/"
        },
        {
          "license": "ABCD-1234-EFGH-5678-IJKL-9012-MNOP-3456",
          "ring_buffer": 4096,
          "http_server_uri": "http://localhost:9999/",
          "ws_server_uri": "ws://localhost:9998/"
        },
        {
          "license": "ABCD-1234-EFGH-5678-IJKL-9012-MNOP-3456",
          "ring_buffer": 4096,
          "http_server_uri": "http://*:9999/",
          "ws_server_uri": "ws://0.0.0.0:9998/"
        }
      ]
    },
    "sinks": {
      "type": "array",
      "description": "List of sink connectors",
      "items": {
        "$ref": "#/definitions/sinkConnector"
      }
    },
    "sources": {
      "type": "array",
      "description": "List of source connectors",
      "items": {
        "$ref": "#/definitions/sourceConnector"
      }
    }
  },
  "required": ["app"],
  "definitions": {
    "baseConnector": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique connector name",
          "default": "myUniqueConnectorName"
        },
        "enabled": {
          "type": "boolean",
          "description": "Is connector enabled",
          "default": true,
          "enum": [ true, false ]
        },
        "scan_interval": {
          "type": "integer",
          "description": "Scanning frequency in milliseconds",
          "default": 1000
        }
      },
      "required": ["name"],
      "examples": [
        {
          "name": "uniqueConnectorName",
          "enabled": true,
          "scan_interval": 1000
        }
      ]
    },
    "baseItem": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique item name",
          "default": "myUniqueItemName"
        },
        "enabled": {
          "type": "boolean",
          "description": "Is item enabled",
          "default": true,
          "enum": [ true, false ]
        },
        "rbe": {
          "type": "boolean",
          "description": "Report data by exception override at item level",
          "default": true,
          "enum": [ true, false ]
        },
        "every": {
          "type": "integer",
          "description": "Execute item every x scan_interval",
          "default": 1
        },
        "address": {
          "type": "string",
          "description": "Source data address, formatting specific to connector type"
        },
        "script": {
          "type": "string",
          "description": "Script executed after source data is read"
        },
        "sink": {
          "type": "object",
          "description": "Sink metadata override at item level",
          "properties": {
            "mtconnect": {
              "type": "string",
              "description": "MTConnect DataItem path",
              "default": "Device[name=device1]/Availability[category=Event]"
            },
            "transform": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "default": "script",
                  "enum": ["script", "scriban", "liquid"]
                },
                "template": {
                  "type": "string",
                  "default": "Message.Data"
                }
              }
            }
          }
        }
      },
      "required": ["name"]
    },
    "ethernetIpItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "type": {
              "type": "string",
              "description": "PLC register type",
              "enum": ["bool", "ubyte", "byte", "ushort", "short", "uint", "int", "ulong", "long", "float", "double", "string"]
            }
          }
        }
      ]
    },
    "beckhoffAdsItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "type": {
              "type": "string",
              "description": "PLC register type",
              "enum": ["bool", "sbyte", "short", "int", "long", "float", "string"]
            }
          }
        }
      ]
    },
    "modbusTcpItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "type": {
              "type": "integer",
              "description": "Register type (1-coil, 2-input, 3-holding register, 4-input register)",
              "enum": [1, 2, 3, 4]
            },
            "count": {
              "type": "integer",
              "description": "Number of consecutive registers to read",
              "default": 1
            }
          }
        }
      ]
    },
    "opcUaItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "namespace": {
              "type": "integer",
              "description": "OPC-UA namespace index",
              "default": 2
            }
          }
        }
      ]
    },
    "siemensS7Item": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "type": {
              "type": "string",
              "description": "PLC register type",
              "enum": ["bool", "sbyte", "short", "int", "long", "float", "string"]
            }
          }
        }
      ]
    },
    "timebaseWsItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "group": {
              "type": "string",
              "description": "Historian item group"
            }
          }
        }
      ]
    },
    "nwsWeatherItem": {
      "allOf": [
        { "$ref": "#/definitions/baseItem" },
        {
          "properties": {
            "forecast": {
              "type": "string",
              "description": "Daily or hourly forecast",
              "enum": ["daily", "hourly"],
              "default": "daily"
            }
          }
        }
      ]
    },
    "sinkConnector": {
      "allOf": [
        { "$ref": "#/definitions/baseConnector" },
        {
          "properties": {
            "connector": {
              "type": "string",
              "description": "Sink connector type",
              "default": "console",
              "enum": [
                "console", "logger", "csvWriter", "httpClient", "httpServer",
                "influxLp", "mongoDb", "mqtt", "mtConnectAgent", "mtConnectShdr",
                "opcUa", "redis", "sparkplugB", "splunkEhSdk1", "splunkEhSdk2",
                "splunkHec", "trakHoundHttp", "websocketServer", "webServer"
              ]
            },
            "exclude_filter": {
              "type": "array",
              "description": "Message path exclusion filter",
              "items": { "type": "string" }
            },
            "include_filter": {
              "type": "array",
              "description": "Message path inclusion filter",
              "items": { "type": "string" }
            },
            "use_sink_transform": {
              "type": "boolean",
              "description": "Execute transform defined on the source connector",
              "default": false,
              "enum": [ true, false ]
            }
          },
          "required": ["connector"]
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["console"] } }
          },
          "then": { "$ref": "#/definitions/consoleSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["logger"] } }
          },
          "then": { "$ref": "#/definitions/loggerSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["csvWriter"] } }
          },
          "then": { "$ref": "#/definitions/csvWriterSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["httpClient"] } }
          },
          "then": { "$ref": "#/definitions/httpClientSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["httpServer"] } }
          },
          "then": { "$ref": "#/definitions/httpServerSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["influxLp"] } }
          },
          "then": { "$ref": "#/definitions/influxLpSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mongoDb"] } }
          },
          "then": { "$ref": "#/definitions/mongoDbSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mqtt"] } }
          },
          "then": { "$ref": "#/definitions/mqttSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mtConnectAgent"] } }
          },
          "then": { "$ref": "#/definitions/mtConnectAgentSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mtConnectShdr"] } }
          },
          "then": { "$ref": "#/definitions/mtConnectShdrSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["opcUa"] } }
          },
          "then": { "$ref": "#/definitions/opcUaSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["redis"] } }
          },
          "then": { "$ref": "#/definitions/redisSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["sparkplugB"] } }
          },
          "then": { "$ref": "#/definitions/sparkplugBSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["splunkEhSdk1"] } }
          },
          "then": { "$ref": "#/definitions/splunkEhSdk1Sink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["splunkEhSdk2"] } }
          },
          "then": { "$ref": "#/definitions/splunkEhSdk2Sink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["splunkHec"] } }
          },
          "then": { "$ref": "#/definitions/splunkHecSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["trakHoundHttp"] } }
          },
          "then": { "$ref": "#/definitions/trakHoundHttpSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["websocketServer"] } }
          },
          "then": { "$ref": "#/definitions/websocketServerSink" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["webServer"] } }
          },
          "then": { "$ref": "#/definitions/webServerSink" }
        }
      ]
    },
    "sourceConnector": {
      "allOf": [
        { "$ref": "#/definitions/baseConnector" },
        {
          "properties": {
            "connector": {
              "type": "string",
              "description": "Source connector type",
              "default": "mqtt",
              "enum": [
                "activeMq", "ascCpc", "beckhoffAds", "ethernetIp", "fanucRobot",
                "haasShdr", "httpServer", "jsonWebScraper", "modbusTcp", "mqtt",
                "msSql", "mtConnectAgent", "nwsWeather", "opcDa", "opcUa",
                "postgres", "redis", "script", "siemensS7", "snmp", "sparkplugB",
                "tcpAscii", "timebaseWs", "udpServer", "smartPac",
                "xmlWebScraper", "yaskawa"
              ]
            },
            "rbe": {
              "type": "boolean",
              "description": "Report data by exception, or unique value",
              "default": true,
              "enum": [ true, false ]
            },
            "lang_script": {
              "type": "string",
              "description": "Python or Lua scripting language",
              "default": "Lua",
              "enum": ["Lua", "Python"]
            },
            "paths_script": {
              "type": "array",
              "description": "Additional paths for scripting libraries",
              "items": { "type": "string" }
            },
            "init_script": {
              "type": "string",
              "description": "Startup script"
            },
            "deinit_script": {
              "type": "string",
              "description": "Shutdown script"
            },
            "enter_script": {
              "type": "string",
              "description": "Execution loop entry script"
            },
            "exit_script": {
              "type": "string",
              "description": "Execution loop exit script"
            },
            "item_script": {
              "type": "string",
              "description": "Script executed for each item when undefined at item level"
            },
            "strip_path_prefix": {
              "type": "boolean",
              "description": "Remove connector name from messages placed in outbox",
              "default": false,
              "enum": [ true, false ]
            },
            "sink": {
              "type": "object",
              "description": "Sink metadata",
              "properties": {
                "transform": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string",
                      "default": "script",
                      "enum": ["script", "scriban", "liquid"]
                    },
                    "template": {
                      "type": "string",
                      "default": "Message.Data"
                    }
                  }
                }
              }
            },
            "items": {
              "type": "array",
              "description": "List of items to read from the source",
              "items": {
                "$ref": "#/definitions/baseItem"
              }
            }
          },
          "required": ["connector"]
        },
        {
          "if": {
            "properties": {
              "connector": {
                "enum": ["activeMq", "haasShdr", "httpServer", "mqtt", "mtConnectAgent", "redis", "sparkplugB", "timebaseWs", "udpServer"]
              }
            }
          },
          "then": {
            "properties": {
              "itemized_read": {
                "type": "boolean",
                "description": "When TRUE, streaming data is matched against the 'items' list and processed, unmatched 'item.address' are dropped. When FALSE, all streaming data is processed.",
                "default": false
              },
              "create_dummy_messages_on_startup": {
                "type": "boolean",
                "description": "Create a zero value message for each item on connector startup",
                "default": false
              }
            }
          }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["activeMq"] } }
          },
          "then": { "$ref": "#/definitions/activeMqSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["ascCpc"] } }
          },
          "then": { "$ref": "#/definitions/ascCpcSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["beckhoffAds"] } }
          },
          "then": { "$ref": "#/definitions/beckhoffAdsSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["ethernetIp"] } }
          },
          "then": { "$ref": "#/definitions/ethernetIpSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["fanucRobot"] } }
          },
          "then": { "$ref": "#/definitions/fanucRobotSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["haasShdr"] } }
          },
          "then": { "$ref": "#/definitions/haasShdrSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["httpServer"] } }
          },
          "then": { "$ref": "#/definitions/httpServerSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["jsonWebScraper"] } }
          },
          "then": { "$ref": "#/definitions/jsonWebScraperSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["modbusTcp"] } }
          },
          "then": { "$ref": "#/definitions/modbusTcpSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mqtt"] } }
          },
          "then": { "$ref": "#/definitions/mqttSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["msSql"] } }
          },
          "then": { "$ref": "#/definitions/msSqlSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["mtConnectAgent"] } }
          },
          "then": { "$ref": "#/definitions/mtConnectAgentSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["nwsWeather"] } }
          },
          "then": { "$ref": "#/definitions/nwsWeatherSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["opcDa"] } }
          },
          "then": { "$ref": "#/definitions/opcDaSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["opcUa"] } }
          },
          "then": { "$ref": "#/definitions/opcUaSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["postgres"] } }
          },
          "then": { "$ref": "#/definitions/postgresSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["redis"] } }
          },
          "then": { "$ref": "#/definitions/redisSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["script"] } }
          },
          "then": { "$ref": "#/definitions/scriptSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["siemensS7"] } }
          },
          "then": { "$ref": "#/definitions/siemensS7Source" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["snmp"] } }
          },
          "then": { "$ref": "#/definitions/snmpSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["sparkplugB"] } }
          },
          "then": { "$ref": "#/definitions/sparkplugBSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["tcpAscii"] } }
          },
          "then": { "$ref": "#/definitions/tcpAsciiSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["timebaseWs"] } }
          },
          "then": { "$ref": "#/definitions/timebaseWsSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["udpServer"] } }
          },
          "then": { "$ref": "#/definitions/udpServerSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["smartPac"] } }
          },
          "then": { "$ref": "#/definitions/smartPacSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["xmlWebScraper"] } }
          },
          "then": { "$ref": "#/definitions/xmlWebScraperSource" }
        },
        {
          "if": {
            "properties": { "connector": { "enum": ["yaskawa"] } }
          },
          "then": { "$ref": "#/definitions/yaskawaSource" }
        }
      ]
    },
    "consoleSink": {
      "description": "Writes data to the console",
      "type": "object",
      "properties": {
        
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "console",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false
        }
      ]
    },
    "loggerSink": {
      "description": "Writes data to an NLog logger",
      "type": "object",
      "properties": {
        
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "logger",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false
        }
      ]
    },
    "csvWriterSink": {
      "description": "Writes data to a CSV file",
      "type": "object",
      "properties": {
        "filename": {
          "type": "string",
          "description": "Absolute or relative file path and file name to write to"
        },
        "filter_duplicate_paths": {
          "type": "boolean",
          "description": "Filter paths with same name, outputting only one instance of each path",
          "default": false
        }
      },
      "required": ["filename"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "csvWriter",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "filename": "C:\\temp\\file.csv",
          "filter_dupliate_paths": false
        }
      ]
    },
    "httpClientSink": {
      "description": "Posts data to an HTTP server",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Resource URL to POST JSON payload to",
          "default": "http://localhost/"
        },
        "headers": {
          "type": "object",
          "description": "Dictionary of request headers",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "httpClient",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "uri": "https://webhook-test.com/a8f1397c82e25e675b2caacdf0d9611b",
          "headers": {
            "Content-Type": "text/plain",
            "Authorization": "None"
          }
        }
      ]
    },
    "httpServerSink": {
      "description": "Starts an HTTP server and serves all data items to external HTTP clients",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "URL to serve items",
          "default": "http://localhost:8080/",
          "pattern": "^https?://.*$"
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "httpServer",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "uri": "http://*:8080"
        }
      ]
    },
    "influxLpSink": {
      "description": "Writes data to an Influx Data bucket",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "URL to your Influx instance"
        },
        "token": {
          "type": "string",
          "description": "Influx token"
        },
        "org_name": {
          "type": "string",
          "description": "Influx organization name"
        },
        "bucket_name": {
          "type": "string",
          "description": "Influx bucket name"
        }
      },
      "required": ["address", "token", "org_name", "bucket_name"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "influxLp",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "192.168.1.1",
          "port": 8086,
          "token": "secret",
          "bucket_name": "bucket1",
          "org_name": "org1"
        }
      ]
    },
    "mongoDbSink": {
      "description": "Writes data to a MongoDB collection",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Database connection string"
        },
        "database": {
          "type": "string",
          "description": "Database name"
        },
        "collection": {
          "type": "string",
          "description": "Collection name"
        }
      },
      "required": ["address", "database", "collection"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "mongoDb",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "mongodb+srv://user:pass@cluster.mongodb.net",
          "database": "dime",
          "collection": "ts"
        }
      ]
    },
    "mqttSink": {
      "description": "Publishes data to an MQTT broker",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Broker hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Broker port",
          "default": 1883
        },
        "qos": {
          "type": "integer",
          "description": "Quality of Service (0, 1, 2)",
          "default": 0,
          "enum": [0, 1, 2]
        },
        "retain": {
          "type": "boolean",
          "description": "Retain published messages",
          "default": true
        },
        "base_topic": {
          "type": "string",
          "description": "Topic prefix for published messages",
          "default": "dime"
        },
        "clean_session": {
          "type": "boolean",
          "description": "MQTT clean session",
          "default": true
        },
        "tls": {
          "type": "boolean",
          "description": "SSL/TLS connection",
          "default": false
        },
        "tls_insecure": {
          "type": "boolean",
          "description": "Allow untrusted certificates",
          "default": false
        },
        "client_cert_path": {
          "type": "string",
          "description": "Relative or absolute path to the client certificate (.pfx)"
        },
        "client_cert_password": {
          "type": "string",
          "description": "Client certificate password"
        },
        "ca_cert_path": {
          "type": "string",
          "description": "Relative or absolute path to the certificate authority certificate"
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "mqtt",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "mqtt.factory.example.com",
          "port": 1883,
          "qos": 1,
          "retain": true,
          "base_topic": "factory/machines",
          "clean_session": true,
          "tls": true,
          "tls_insecure": false,
          "client_cert_path": "./certs/client.pfx",
          "client_cert_password": "certpass",
          "ca_cert_path": "./certs/ca.crt",
          "username": "mqttuser",
          "password": "mqttpass"
        }
      ]
    },
    "mtConnectAgentSink": {
      "description": "Serve MTConnect embedded Agent",
      "type": "object",
      "properties": {
        "port": {
          "type": "integer",
          "description": "Agent port",
          "default": 5000
        }
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "mtConnectAgent",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "port": 5000
        }
      ]
    },
    "mtConnectShdrSink": {
      "description": "Stream SHDR to an external Agent",
      "type": "object",
      "properties": {
        "port": {
          "type": "integer",
          "description": "SHDR listening port",
          "default": 7878
        },
        "device_key": {
          "type": "string",
          "description": "Device key"
        },
        "heartbeat_interval": {
          "type": "integer",
          "description": "Ping/Pong frequency in milliseconds",
          "default": 10000
        },
        "filter_duplicates": {
          "type": "boolean",
          "description": "Filter duplicates",
          "default": true
        },
        "output_folder": {
          "type": "string",
          "description": "Absolute or relative folder path where to write Devices.xml",
          "default": "./Output/MTConnect"
        }
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "mtConnectShdr",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "port": 7878,
          "device_key": "CNC-123",
          "heartbeat_interval": 10000,
          "filter_duplicates": true,
          "output_folder": "./Output/MTConnect/Machine1"
        }
      ]
    },
    "opcUaSink": {
      "description": "Writes items to an OPC-UA server",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Server port",
          "default": 49320
        },
        "path": {
          "type": "string",
          "description": "Server path"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds",
          "default": 1000
        },
        "mode": {
          "type": "integer",
          "description": "1=None, 2=Sign, 3=SignAndEncrypt",
          "default": 1,
          "enum": [1, 2, 3]
        },
        "policy": {
          "type": "integer",
          "description": "1=None, 2=Basic256, 3=Basic128Rsa15, 4=Basic256Sha256",
          "default": 1,
          "enum": [1, 2, 3, 4]
        },
        "anonymous": {
          "type": "boolean",
          "description": "Connect anonymously",
          "default": false
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "opcUa",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "opcua.factory.example.com",
          "port": 49320,
          "path": "",
          "timeout": 2000,
          "mode": 1,
          "policy": 1,
          "anonymous": false,
          "username": "opcuser",
          "password": "opcpassword"
        }
      ]
    },
    "redisSink": {
      "description": "Writes data to Redis",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Server port",
          "default": 6379
        },
        "database": {
          "type": "integer",
          "description": "Database ID",
          "default": 0
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "redis",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "192.168.1.1",
          "port": 6379,
          "database": 0
        }
      ]
    },
    "sparkplugBSink": {
      "description": "Publishes data to a SparkplugB host",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Host hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Host port",
          "default": 1883
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        },
        "host_id": {
          "type": "string",
          "description": "Host ID",
          "default": "dime"
        },
        "group_id": {
          "type": "string",
          "description": "Group ID",
          "default": "dime"
        },
        "node_id": {
          "type": "string",
          "description": "Node ID",
          "default": "dime"
        },
        "device_id": {
          "type": "string",
          "description": "Device ID",
          "default": "dime"
        },
        "reconnect_interval": {
          "type": "integer",
          "description": "Reconnect interval in milliseconds",
          "default": 15000
        },
        "birth_delay": {
          "type": "integer",
          "description": "Delay birth certificate creation in milliseconds",
          "default": 10000
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "sparkplugB",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "mqtt.scada.example.com",
          "port": 1883,
          "username": "sparkplug_user",
          "password": "sparkplug_password",
          "host_id": "central_broker",
          "group_id": "Factory1",
          "node_id": "Line5",
          "device_id": "Robot1",
          "reconnect_interval": 10000,
          "birth_delay": 15000
        }
      ]
    },
    "splunkEhSdk1Sink": {
      "description": "Writes data to Splunk via Splunk EdgeHub SDK",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Internal address",
          "default": "http://host.docker.internal"
        },
        "port": {
          "type": "integer",
          "description": "Internal port",
          "default": 50051
        },
        "numbers_to_metrics": {
          "type": "boolean",
          "description": "Write numbers as metrics",
          "default": false
        }
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "splunkEhSdk1",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "http://host.docker.internal",
          "port": 50051,
          "numbers_to_metrics": false
        }
      ]
    },
    "splunkEhSdk2Sink": {
      "description": "Writes data to Splunk via Splunk EdgeHub SDK v2",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Internal address",
          "default": "http://host.docker.internal"
        },
        "port": {
          "type": "integer",
          "description": "Internal port",
          "default": 50051
        }
      },
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "splunkEhSdk2",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "http://host.docker.internal",
          "port": 50051
        }
      ]
    },
    "splunkHecSink": {
      "description": "Writes data to Splunk via Splunk HEC",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Splunk hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Splunk HEC port",
          "default": 8088
        },
        "use_ssl": {
          "type": "boolean",
          "description": "Use HTTP or HTTPS",
          "default": false
        },
        "token": {
          "type": "string",
          "description": "Splunk HEC token"
        },
        "event_or_metric": {
          "type": "string",
          "description": "Send as 'event' or 'metric'",
          "default": "event",
          "enum": ["event", "metric"]
        },
        "source": {
          "type": "string",
          "description": "Source"
        },
        "source_type": {
          "type": "string",
          "description": "Source type",
          "default": "_json"
        }
      },
      "required": ["address", "token"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "splunkHec",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "splunk.example.com",
          "port": 8088,
          "use_ssl": true,
          "token": "A1B2C3D4-E5F6-G7H8-I9J0-K1L2M3N4O5P6",
          "event_or_metric": "event",
          "source": "industrial_sensors",
          "source_type": "_json"
        }
      ]
    },
    "trakHoundHttpSink": {
      "description": "Writes data to a Trakhound server",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Trakhound hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Trakhound port",
          "default": 8472
        },
        "use_ssl": {
          "type": "boolean",
          "description": "Use HTTPS or HTTP",
          "default": false
        },
        "router": {
          "type": "string",
          "description": "Router name"
        },
        "host_path": {
          "type": "string",
          "description": "Host path"
        },
        "base_path": {
          "type": "string",
          "description": "Base path"
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "trakhoundHttp",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "address": "trakhound.example.com",
          "port": 8472,
          "use_ssl": true,
          "router": "default",
          "host_path": "",
          "base_path": "Ladder99:/DIME/HttpSink"
        }
      ]
    },
    "websocketServerSink": {
      "description": "Serve data from a Websocket Server",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Websocket server address",
          "default": "ws://127.0.0.1:8082/",
          "pattern": "^wss?://.*$"
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "websocketServer",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "uri": "ws://127.0.0.1:8082/"
        }
      ]
    },
    "webServerSink": {
      "description": "Serve data from an HTTP Server",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Web server address",
          "default": "http://127.0.0.1:8090/",
          "pattern": "^http?://.*$"
        },
        "web_root": {
          "type": "string",
          "description": "Web root path",
          "default": "./Configs/web"
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "webServer",
          "scan_interval": 1000,
          "include_filter": [],
          "exclude_filter": [],
          "use_sink_transform": false,
          "uri": "http://127.0.0.1:8090/",
          "web_root": "./Configs/web"
        }
      ]
    },
    "activeMqSource": {
      "description": "Subscribes to ActiveMQ topics and queues",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Broker URI"
        },
        "username": {
          "type": "string",
          "description": "Broker username"
        },
        "password": {
          "type": "string",
          "description": "Broker password"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "activeMqBroker1",
          "enabled": true,
          "connector": "activeMq",
          "scan_interval": 500,
          "rbe": true,
          "itemized_read": true,
          "lang_script": "Lua",
          "address": "activemq:tcp://192.168.1.100:61616",
          "username": "dime_user",
          "password": "secure_password",
          "init_script": "-- Initialize JSON library for message parsing\njson = require('json')\nstringx = require('pl.stringx')\nprint('ActiveMQ connector initialized')",
          "enter_script": "-- Log each polling cycle\n-- print('ActiveMQ polling cycle started')",
          "exit_script": "-- print('ActiveMQ polling cycle completed')",
          "items": [
            {
              "name": "ProductionEvents",
              "enabled": true,
              "address": "topic://PRODUCTION.EVENTS",
              "rbe": false,
              "every": 1,
              "script": "-- Parse JSON message and extract event type\nlocal data = json.decode(result)\nreturn data.eventType or 'Unknown'"
            },
            {
              "name": "MachineAlerts",
              "enabled": true,
              "address": "topic://FACTORY.ALERTS.MACHINE",
              "rbe": true,
              "every": 1,
              "script": "-- Parse alert message and format for downstream\nlocal alert = json.decode(result)\nlocal severity = alert.severity or 'INFO'\nlocal message = alert.message or 'No message'\nreturn severity .. ': ' .. message"
            },
            {
              "name": "QualityReports",
              "enabled": true,
              "address": "queue://QUALITY.REPORTS",
              "rbe": true,
              "every": 1,
              "script": "-- Extract quality metrics\nlocal report = json.decode(result)\nif report.passRate then\n  return tonumber(report.passRate)\nelse\n  return nil\nend"
            },
            {
              "name": "SystemHeartbeat",
              "enabled": true,
              "address": "topic://SYSTEM.HEARTBEAT",
              "rbe": false,
              "every": 1,
              "script": "-- Simple heartbeat processing\nlocal hb = json.decode(result)\nreturn hb.timestamp or os.time()"
            },
            {
              "name": "OrderUpdates",
              "enabled": true,
              "address": "queue://ORDERS.UPDATES",
              "rbe": true,
              "every": 1,
              "script": "-- Process order status updates\nlocal order = json.decode(result)\nif order.status and order.orderId then\n  emit('./OrderStatus_' .. order.orderId, order.status)\n  return order.orderId .. ': ' .. order.status\nend\nreturn nil"
            },
            {
              "name": "TemperatureSensors",
              "enabled": true,
              "address": "topic://SENSORS.TEMPERATURE",
              "rbe": true,
              "every": 1,
              "script": "-- Parse temperature data\nlocal sensor = json.decode(result)\nif sensor.value and sensor.sensorId then\n  -- Emit individual sensor readings\n  emit('./Temp_' .. sensor.sensorId, tonumber(sensor.value))\n  -- Return averaged value for this item\n  return tonumber(sensor.value)\nend\nreturn nil",
              "sink": {
                "mtconnect": "Device[name=factory1]/Controller/Temperature[category=Sample]"
              }
            },
            {
              "name": "ProductionCommands",
              "enabled": true,
              "address": "queue://PRODUCTION.COMMANDS",
              "rbe": true,
              "every": 1,
              "script": "-- Process production commands\nlocal cmd = json.decode(result)\nif cmd.command == 'START' then\n  return 'Production Started'\nelseif cmd.command == 'STOP' then\n  return 'Production Stopped'\nelseif cmd.command == 'PAUSE' then\n  return 'Production Paused'\nelse\n  return 'Unknown Command: ' .. (cmd.command or 'None')\nend"
            },
            {
              "name": "InventoryUpdates",
              "enabled": true,
              "address": "topic://INVENTORY.UPDATES",
              "rbe": true,
              "every": 2,
              "script": "-- Track inventory levels\nlocal inv = json.decode(result)\nif inv.partNumber and inv.quantity then\n  -- Emit individual part quantities\n  emit('./Inventory_' .. inv.partNumber, tonumber(inv.quantity))\n  -- Return summary for this item\n  return inv.partNumber .. ': ' .. inv.quantity\nend\nreturn nil"
            },
            {
              "name": "ErrorLogs",
              "enabled": true,
              "address": "queue://SYSTEM.ERRORS",
              "rbe": false,
              "every": 1,
              "script": "-- Process error messages\nlocal error = json.decode(result)\nlocal timestamp = error.timestamp or os.date('%Y-%m-%d %H:%M:%S')\nlocal severity = error.level or 'ERROR'\nlocal message = error.message or 'Unknown error'\nreturn timestamp .. ' [' .. severity .. '] ' .. message"
            },
            {
              "name": "WildcardMonitor",
              "enabled": true,
              "address": "topic://FACTORY.>",
              "rbe": false,
              "every": 1,
              "script": "-- Monitor all factory topics (wildcard)\n-- Log message source and basic info\nlocal data = json.decode(result)\nlocal source = data.source or 'Unknown'\nprint('Received message from: ' .. source)\nreturn 'Message from ' .. source"
            }
          ],
          "strip_path_prefix": false,
          "create_dummy_messages_on_startup": true,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "ascCpcSource": {
      "description": "Reads data from ASC autoclave systems",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "CPC instance hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "CPC instance port",
          "default": 9999
        },
        "bypass_ping": {
          "type": "boolean",
          "description": "Ping CPC host before reading to determine connector connection status",
          "default": false
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "autoclave1",
          "enabled": true,
          "connector": "ascCpc",
          "scan_interval": 2500,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.50",
          "port": 9999,
          "bypass_ping": true,
          "init_script": "-- Initialize autoclave monitoring\nprint('ASC CPC Autoclave connector initialized')\n-- Define alarm state mappings\nAlarmStates = {\n  [0] = 'Normal',\n  [1] = 'Warning', \n  [2] = 'Fault'\n}",
          "enter_script": "-- Check system time for cycle tracking\ncurrentTime = os.time()",
          "exit_script": "-- Log completion of data collection cycle\n-- print('Autoclave data collection completed')",
          "items": [
            {
              "name": "Availability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate availability based on connection status\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nreturn isConnected and 'Available' or 'Unavailable'",
              "sink": {
                "mtconnect": "Device[Name=autoclave1]/Availability[Category=Event]"
              }
            },
            {
              "name": "Temperature",
              "enabled": true,
              "address": ".Autoclave.Inputs.AIRTC\\Value",
              "rbe": true,
              "every": 1,
              "script": "-- Convert temperature and validate range\nlocal temp = tonumber(result)\nif temp and temp > -50 and temp < 500 then\n  return math.floor(temp * 10) / 10\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[Name=autoclave1]/Controller/Path/Temperature[Category=Sample]"
              }
            },
            {
              "name": "Pressure",
              "enabled": true,
              "address": ".Autoclave.Inputs.PRESS\\Value",
              "rbe": true,
              "every": 1,
              "script": "-- Process pressure reading\nlocal pressure = tonumber(result)\nif pressure and pressure >= 0 and pressure <= 100 then\n  return math.floor(pressure * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[Name=autoclave1]/Controller/Path/Pressure[Category=Sample]"
              }
            },
            {
              "name": "PumpHours",
              "enabled": true,
              "address": ".Autoclave.Scripts.MotorHours.CoolPumpAOn\\Value",
              "rbe": true,
              "every": 5,
              "script": "-- Track pump operating hours\nlocal hours = tonumber(result)\nif hours and hours >= 0 then\n  return math.floor(hours * 100) / 100\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[Name=autoclave1]/Controller/Path/Hours[Category=Sample]"
              }
            },
            {
              "name": "UserOperator",
              "enabled": true,
              "address": ".Autoclave.Variables.OperatorName\\Value",
              "rbe": true,
              "every": 10,
              "script": "-- Clean operator name\nlocal operator = tostring(result or '')\noperator = string.gsub(operator, '^%s*(.-)%s*$', '%1') -- trim whitespace\nreturn operator ~= '' and operator or 'Unknown'"
            },
            {
              "name": "Program",
              "enabled": true,
              "address": ".Autoclave.RecipeProcessor.Recipe.RecipeData\\Description",
              "rbe": true,
              "every": 3,
              "script": "-- Process current recipe/program\nlocal program = tostring(result or '')\nprogram = string.gsub(program, '^%s*(.-)%s*$', '%1')\nreturn program ~= '' and program or 'No Program'"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "address": ".Autoclave.RecipeProcessor.Recipe.RecipeData\\TotalTime",
              "rbe": true,
              "every": 5,
              "script": "-- Convert cycle time to minutes\nlocal timeSeconds = tonumber(result)\nif timeSeconds and timeSeconds > 0 then\n  return math.floor(timeSeconds / 60 * 10) / 10 -- minutes with 1 decimal\nelse\n  return 0\nend"
            },
            {
              "name": "VacuumLevel",
              "enabled": true,
              "address": ".Autoclave.Inputs.VACUUM\\Value",
              "rbe": true,
              "every": 1,
              "script": "-- Process vacuum level\nlocal vacuum = tonumber(result)\nif vacuum and vacuum >= 0 and vacuum <= 30 then\n  return math.floor(vacuum * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "ControlPowerConditionTriggered",
              "enabled": true,
              "address": ".Autoclave.Alarms.ControlPower\\Condition",
              "rbe": true,
              "every": 1,
              "script": "-- Store control power condition in cache\nset('cptrig', result)\nreturn nil -- Don't emit this directly"
            },
            {
              "name": "ControlPowerAlarmActive",
              "enabled": true,
              "address": ".Autoclave.Alarms.ControlPower\\AlarmActive",
              "rbe": true,
              "every": 1,
              "script": "-- Store control power alarm status in cache\nset('cpalm', result)\nreturn nil -- Don't emit this directly"
            },
            {
              "name": "ControlPowerCondition",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Combine control power status\nlocal cptrig = cache('cptrig', false)\nlocal cpalm = cache('cpalm', false)\nif cpalm then\n  return 'Fault'\nelseif cptrig then\n  return 'Warning'\nelse\n  return 'Normal'\nend"
            },
            {
              "name": "DoorStatus",
              "enabled": true,
              "address": ".Autoclave.Inputs.DOOROPEN\\Value",
              "rbe": true,
              "every": 2,
              "script": "-- Process door status\nlocal doorOpen = result\nif doorOpen == true or doorOpen == 1 then\n  return 'Open'\nelse\n  return 'Closed'\nend"
            },
            {
              "name": "HeaterStatus",
              "enabled": true,
              "address": ".Autoclave.Outputs.HEATER\\Value",
              "rbe": true,
              "every": 2,
              "script": "-- Process heater status\nlocal heaterOn = result\nif heaterOn == true or heaterOn == 1 then\n  return 'On'\nelse\n  return 'Off'\nend"
            },
            {
              "name": "CycleState",
              "enabled": true,
              "address": ".Autoclave.RecipeProcessor.Recipe.State",
              "rbe": true,
              "every": 1,
              "script": "-- Map cycle state numbers to text\nlocal state = tonumber(result)\nlocal states = {\n  [0] = 'Idle',\n  [1] = 'Running',\n  [2] = 'Paused',\n  [3] = 'Complete',\n  [4] = 'Fault',\n  [5] = 'Aborting'\n}\nreturn states[state] or 'Unknown'"
            },
            {
              "name": "AlarmCount",
              "enabled": true,
              "address": ".Autoclave.Alarms.ActiveCount",
              "rbe": true,
              "every": 3,
              "script": "-- Track total active alarms\nlocal count = tonumber(result)\nreturn count and count >= 0 and count or 0"
            },
            {
              "name": "ProcessPhase",
              "enabled": true,
              "address": ".Autoclave.RecipeProcessor.CurrentPhase\\Name",
              "rbe": true,
              "every": 2,
              "script": "-- Current process phase\nlocal phase = tostring(result or '')\nphase = string.gsub(phase, '^%s*(.-)%s*$', '%1')\nreturn phase ~= '' and phase or 'No Phase'"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "beckhoffAdsSource": {
      "description": "Reads data from Beckhoff PLCs",
      "type": "object",
      "properties": {
        "local_netid": {
          "type": "string",
          "description": "Local AMS Net ID"
        },
        "address": {
          "type": "string",
          "description": "Remote AMS Net ID"
        },
        "target_ip": {
          "type": "string",
          "description": "IPv4 address to remote AMS Net ID"
        },
        "port": {
          "type": "integer",
          "description": "ADS port",
          "default": 851
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/beckhoffAdsItem" }
        }
      },
      "required": ["local_netid", "address", "target_ip"],
      "examples": [
        {
          "name": "beckhoffPlc1",
          "enabled": true,
          "connector": "beckhoffAds",
          "scan_interval": 1000,
          "rbe": true,
          "lang_script": "Lua",
          "local_netid": "192.168.1.100.1.1",
          "address": "192.168.1.50.1.1",
          "target_ip": "192.168.1.50",
          "port": 851,
          "init_script": "print('Beckhoff ADS connector initialized')",
          "items": [
            {
              "name": "SystemRunning",
              "enabled": true,
              "type": "bool",
              "address": "MAIN.bSystemRunning",
              "rbe": true,
              "every": 1,
              "script": "return result and 'Running' or 'Stopped'"
            },
            {
              "name": "ProductionCount",
              "enabled": true,
              "type": "int",
              "address": "MAIN.iProductionCount",
              "rbe": true,
              "every": 1
            },
            {
              "name": "Temperature",
              "enabled": true,
              "type": "float",
              "address": "MAIN.rTemperature",
              "rbe": true,
              "every": 2,
              "script": "return math.floor(result * 100) / 100"
            },
            {
              "name": "OperatorName",
              "enabled": true,
              "type": "string",
              "address": "MAIN.sOperatorName",
              "rbe": true,
              "every": 5
            },
            {
              "name": "ErrorCode",
              "enabled": true,
              "type": "short",
              "address": "MAIN.iErrorCode",
              "rbe": true,
              "every": 1,
              "script": "return result == 0 and 'No Error' or ('Error: ' .. tostring(result))"
            },
            {
              "name": "Speed",
              "enabled": true,
              "type": "float",
              "address": "MAIN.rSpeed",
              "rbe": true,
              "every": 1,
              "sink": {
                "mtconnect": "Device[name=beckhoff1]/Controller/Speed[category=Sample]"
              }
            },
            {
              "name": "MaintenanceFlag",
              "enabled": true,
              "type": "bool",
              "address": "MAIN.bMaintenanceRequired",
              "rbe": true,
              "every": 10
            },
            {
              "name": "BatchNumber",
              "enabled": true,
              "type": "long",
              "address": "MAIN.lBatchNumber",
              "rbe": true,
              "every": 1
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "ethernetIpSource": {
      "description": "Reads data from Allen-Bradley PLCs",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "PLC type",
          "default": "ControlLogix",
          "enum": ["ControlLogix", "Plc5", "Slc500", "LogixPccc", "Micro800", "MicroLogix", "Omron"]
        },
        "address": {
          "type": "string",
          "description": "PLC hostname, IP address"
        },
        "path": {
          "type": "string",
          "description": "Connection path",
          "default": "1,0"
        },
        "log": {
          "type": "integer",
          "description": "Library log level (0: None … 5: Verbose)",
          "default": 0
        },
        "timeout": {
          "type": "integer",
          "description": "PLC read timeout in milliseconds",
          "default": 1000
        },
        "bypass_ping": {
          "type": "boolean",
          "description": "Ping PLC before reading to determine connector connection status",
          "default": false
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/ethernetIpItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "rockwellPlc1",
          "enabled": true,
          "connector": "ethernetIp",
          "scan_interval": 1500,
          "rbe": true,
          "lang_script": "Lua",
          "type": "MicroLogix",
          "address": "192.168.1.20",
          "path": "1,0",
          "log": 0,
          "timeout": 1000,
          "bypass_ping": true,
          "init_script": "-- Initialize PLC data processing\nprint('Rockwell PLC connector initialized')\n-- Define execution state mappings\nExecutionStates = {\n  [0] = 'Idle',\n  [1] = 'Running',\n  [2] = 'Fault',\n  [3] = 'Maintenance'\n}",
          "enter_script": "-- Log PLC read cycle start\n-- print('Starting PLC read cycle')",
          "exit_script": "-- Calculate cycle efficiency\nlocal cycleTime = cache('./CycleTime', 0)\nlocal targetTime = 45\nif cycleTime > 0 then\n  local efficiency = (targetTime / cycleTime) * 100\n  emit('./CycleEfficiency', math.floor(efficiency * 10) / 10)\nend",
          "items": [
            {
              "name": "SystemAvailability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate system availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal isFaulted = cache('./$SYSTEM/IsFaulted', false)\nif not isConnected then\n  return 'Unavailable'\nelseif isFaulted then\n  return 'Fault'\nelse\n  return 'Available'\nend",
              "sink": {
                "mtconnect": "Device[name=line1]/Availability[category=Event]"
              }
            },
            {
              "name": "Execution",
              "enabled": true,
              "type": "bool",
              "address": "B3:0/3",
              "rbe": true,
              "every": 1,
              "script": "-- Map execution state to text\nlocal states = { [false]='Idle', [true]='Running' }\nreturn states[result]",
              "sink": {
                "mtconnect": "Device[name=line1]/Controller/Execution[category=Event]"
              }
            },
            {
              "name": "GoodPartCount",
              "enabled": true,
              "type": "int",
              "address": "N7:1",
              "rbe": true,
              "every": 1,
              "script": "-- Validate part count range\nlocal count = tonumber(result)\nif count and count >= 0 and count <= 999999 then\n  return count\nelse\n  return cache('./GoodPartCount', 0)\nend",
              "sink": {
                "mtconnect": "Device[name=line1]/Controller/PartCount[category=Event,subType=Good]"
              }
            },
            {
              "name": "BadPartCount",
              "enabled": true,
              "type": "int",
              "address": "N7:2",
              "rbe": true,
              "every": 1,
              "script": "-- Track bad parts with validation\nlocal count = tonumber(result)\nif count and count >= 0 then\n  return count\nelse\n  return cache('./BadPartCount', 0)\nend"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "type": "float",
              "address": "F8:1",
              "rbe": true,
              "every": 1,
              "script": "-- Process cycle time in seconds\nlocal time = tonumber(result)\nif time and time > 0 and time < 300 then\n  return math.floor(time * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "SpindleSpeed",
              "enabled": true,
              "type": "float",
              "address": "F8:2",
              "rbe": true,
              "every": 1,
              "script": "-- Monitor spindle RPM\nlocal rpm = tonumber(result)\nif rpm and rpm >= 0 and rpm <= 5000 then\n  return math.floor(rpm)\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=line1]/Controller/SpindleSpeed[category=Sample]"
              }
            },
            {
              "name": "ConveyorRunning",
              "enabled": true,
              "type": "bool",
              "address": "B3:1/0",
              "rbe": true,
              "every": 2,
              "script": "-- Conveyor status\nreturn result and 'Running' or 'Stopped'"
            },
            {
              "name": "EmergencyStop",
              "enabled": true,
              "type": "bool",
              "address": "B3:0/0",
              "rbe": true,
              "every": 1,
              "script": "-- Emergency stop status (inverted logic)\nreturn result and 'Normal' or 'Activated'"
            },
            {
              "name": "Temperature1",
              "enabled": true,
              "type": "float",
              "address": "F8:10",
              "rbe": true,
              "every": 2,
              "script": "-- Temperature sensor 1\nlocal temp = tonumber(result)\nif temp and temp > -40 and temp < 150 then\n  return math.floor(temp * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "Temperature2",
              "enabled": true,
              "type": "float",
              "address": "F8:11",
              "rbe": true,
              "every": 2,
              "script": "-- Temperature sensor 2\nlocal temp = tonumber(result)\nif temp and temp > -40 and temp < 150 then\n  return math.floor(temp * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "Pressure",
              "enabled": true,
              "type": "float",
              "address": "F8:3",
              "rbe": true,
              "every": 2,
              "script": "-- Hydraulic pressure in PSI\nlocal pressure = tonumber(result)\nif pressure and pressure >= 0 and pressure <= 3000 then\n  return math.floor(pressure * 10) / 10\nelse\n  return 0\nend"
            },
            {
              "name": "CurrentProgram",
              "enabled": true,
              "type": "int",
              "address": "N7:10",
              "rbe": true,
              "every": 5,
              "script": "-- Map program number to name\nlocal progNum = tonumber(result)\nlocal programs = {\n  [1] = 'DRILL_PROGRAM_A',\n  [2] = 'MILL_PROGRAM_B', \n  [3] = 'TAP_PROGRAM_C',\n  [4] = 'BORE_PROGRAM_D'\n}\nreturn programs[progNum] or ('PROGRAM_' .. (progNum or 0))"
            },
            {
              "name": "ToolNumber",
              "enabled": true,
              "type": "int",
              "address": "N7:11",
              "rbe": true,
              "every": 3,
              "script": "-- Current tool number\nlocal tool = tonumber(result)\nif tool and tool >= 1 and tool <= 99 then\n  return tool\nelse\n  return 0\nend"
            },
            {
              "name": "AlarmCode",
              "enabled": true,
              "type": "int",
              "address": "N7:20",
              "rbe": true,
              "every": 1,
              "script": "-- Process alarm codes\nlocal alarm = tonumber(result)\nif alarm == 0 then\n  return 'No Alarm'\nelse\n  local alarmCodes = {\n    [100] = 'Low Pressure',\n    [101] = 'High Temperature',\n    [102] = 'Tool Break',\n    [103] = 'Spindle Fault',\n    [104] = 'Conveyor Jam'\n  }\n  return alarmCodes[alarm] or ('Alarm Code: ' .. alarm)\nend"
            },
            {
              "name": "FeedRate",
              "enabled": true,
              "type": "float",
              "address": "F8:4",
              "rbe": true,
              "every": 2,
              "script": "-- Feed rate in IPM\nlocal feed = tonumber(result)\nif feed and feed >= 0 and feed <= 500 then\n  return math.floor(feed * 100) / 100\nelse\n  return 0\nend"
            },
            {
              "name": "PowerConsumption",
              "enabled": true,
              "type": "float",
              "address": "F8:5",
              "rbe": true,
              "every": 3,
              "script": "-- Power consumption in kW\nlocal power = tonumber(result)\nif power and power >= 0 and power <= 100 then\n  return math.floor(power * 100) / 100\nelse\n  return 0\nend"
            },
            {
              "name": "ProductionShift",
              "enabled": true,
              "type": "int",
              "address": "N7:30",
              "rbe": true,
              "every": 10,
              "script": "-- Map shift numbers\nlocal shift = tonumber(result)\nlocal shifts = {\n  [1] = 'Day Shift',\n  [2] = 'Evening Shift',\n  [3] = 'Night Shift'\n}\nreturn shifts[shift] or 'Unknown Shift'"
            },
            {
              "name": "MaintenanceMode",
              "enabled": true,
              "type": "bool",
              "address": "B3:2/0",
              "rbe": true,
              "every": 5,
              "script": "-- Maintenance mode status\nreturn result and 'Active' or 'Inactive'"
            },
            {
              "name": "QualityGate",
              "enabled": true,
              "type": "bool",
              "address": "B3:3/0",
              "rbe": true,
              "every": 1,
              "script": "-- Quality gate pass/fail\nreturn result and 'Pass' or 'Fail'"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "fanucRobotSource": {
      "description": "Reads R-J3iB, R-30iA, R-30iB Fanuc Robot controllers using SNPX",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Robot hostname, IP address"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "fanucRobot1",
          "enabled": true,
          "connector": "fanucRobot",
          "scan_interval": 1000,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.100",
          "init_script": "-- Initialize Fanuc Robot monitoring\nprint('Fanuc Robot connector initialized')\n-- Define robot status mappings\nRobotStates = {\n  [0] = 'Stopped',\n  [1] = 'Running',\n  [2] = 'Paused',\n  [3] = 'Error',\n  [4] = 'Emergency_Stop'\n}\n-- Position conversion factors\nMM_TO_INCHES = 0.0393701",
          "enter_script": "-- Log robot monitoring cycle\n-- print('Robot data collection cycle started')",
          "exit_script": "-- Calculate robot utilization\nlocal isRunning = cache('./RobotRunning', false)\nlocal currentTime = os.time()\nlocal lastTime = cache('last_util_time', currentTime)\nlocal runTime = cache('total_run_time', 0)\nif isRunning and currentTime > lastTime then\n  runTime = runTime + (currentTime - lastTime)\n  set('total_run_time', runTime)\nend\nset('last_util_time', currentTime)\n-- Calculate utilization percentage over last hour\nlocal utilization = (runTime / 3600) * 100\nif utilization <= 100 then\n  emit('./Utilization', math.floor(utilization * 10) / 10)\nend",
          "items": [
            {
              "name": "PositionX",
              "enabled": true,
              "address": "worldCartesianPosition.X",
              "rbe": true,
              "every": 1,
              "script": "-- X-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -3000 and pos <= 3000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/XPosition[category=Sample]"
              }
            },
            {
              "name": "PositionY",
              "enabled": true,
              "address": "worldCartesianPosition.Y",
              "rbe": true,
              "every": 1,
              "script": "-- Y-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -3000 and pos <= 3000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/YPosition[category=Sample]"
              }
            },
            {
              "name": "PositionZ",
              "enabled": true,
              "address": "worldCartesianPosition.Z",
              "rbe": true,
              "every": 1,
              "script": "-- Z-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -1000 and pos <= 1000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/ZPosition[category=Sample]"
              }
            },
            {
              "name": "Joint1Position",
              "enabled": true,
              "address": "worldJointPosition.J1",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 1 angle in degrees\nlocal angle = tonumber(result)\nif angle and angle >= -180 and angle <= 180 then\n  return math.floor(angle * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "Joint2Position",
              "enabled": true,
              "address": "worldJointPosition.J2",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 2 angle in degrees\nlocal angle = tonumber(result)\nif angle and angle >= -180 and angle <= 180 then\n  return math.floor(angle * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "Joint3Position",
              "enabled": true,
              "address": "worldJointPosition.J3",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 3 angle in degrees\nlocal angle = tonumber(result)\nif angle and angle >= -180 and angle <= 180 then\n  return math.floor(angle * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "RobotRunning",
              "enabled": true,
              "address": "SO.1",
              "rbe": true,
              "every": 1,
              "script": "-- Robot running status from system output\nlocal running = result == 1 or result == true\nreturn running and 'Running' or 'Stopped'"
            },
            {
              "name": "ProgramRunning",
              "enabled": true,
              "address": "SO.2",
              "rbe": true,
              "every": 1,
              "script": "-- Program execution status\nlocal progRunning = result == 1 or result == true\nreturn progRunning and 'Active' or 'Inactive'"
            },
            {
              "name": "ErrorActive",
              "enabled": true,
              "address": "SO.10",
              "rbe": true,
              "every": 1,
              "script": "-- Error/alarm status\nlocal hasError = result == 1 or result == true\nreturn hasError"
            },
            {
              "name": "EmergencyStop",
              "enabled": true,
              "address": "SI.1",
              "rbe": true,
              "every": 1,
              "script": "-- Emergency stop status\nlocal estop = result == 1 or result == true\nreturn estop and 'Activated' or 'Normal'"
            },
            {
              "name": "HomePosition",
              "enabled": true,
              "address": "SI.5",
              "rbe": true,
              "every": 2,
              "script": "-- Robot at home position\nlocal atHome = result == 1 or result == true\nreturn atHome and 'At_Home' or 'Away_From_Home'"
            },
            {
              "name": "GripperOpen",
              "enabled": true,
              "address": "GO.1",
              "rbe": true,
              "every": 1,
              "script": "-- Gripper status\nlocal gripperOpen = result == 1 or result == true\nreturn gripperOpen and 'Open' or 'Closed'"
            },
            {
              "name": "PartPresent",
              "enabled": true,
              "address": "GI.1",
              "rbe": true,
              "every": 1,
              "script": "-- Part presence sensor\nlocal partPresent = result == 1 or result == true\nreturn partPresent and 'Present' or 'Absent'"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "address": "NumericRegisters.1",
              "rbe": true,
              "every": 1,
              "script": "-- Cycle time in seconds\nlocal time = tonumber(result)\nif time and time > 0 and time < 600 then\n  return math.floor(time * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "PartCount",
              "enabled": true,
              "address": "NumericRegisters.5",
              "rbe": true,
              "every": 1,
              "script": "-- Total parts produced\nlocal count = tonumber(result)\nif count and count >= 0 and count <= 999999 then\n  return count\nelse\n  return cache('./PartCount', 0)\nend"
            },
            {
              "name": "ProgramNumber",
              "enabled": true,
              "address": "NumericRegisters.10",
              "rbe": true,
              "every": 3,
              "script": "-- Current program number\nlocal progNum = tonumber(result)\nif progNum and progNum >= 1 and progNum <= 99 then\n  return 'PROG_' .. string.format('%02d', progNum)\nelse\n  return 'No_Program'\nend"
            },
            {
              "name": "OverridePercent",
              "enabled": true,
              "address": "NumericRegisters.15",
              "rbe": true,
              "every": 2,
              "script": "-- Speed override percentage\nlocal override = tonumber(result)\nif override and override >= 1 and override <= 300 then\n  return override\nelse\n  return 100\nend"
            },
            {
              "name": "OperatorMessage",
              "enabled": true,
              "address": "StringRegisters.1",
              "rbe": true,
              "every": 5,
              "script": "-- Current operator message\nlocal message = tostring(result or '')\nmessage = string.gsub(message, '^%s*(.-)%s*$', '%1')\nreturn message ~= '' and message or 'No_Message'"
            },
            {
              "name": "RobotMode",
              "enabled": true,
              "address": "IntegerSystemVariables.1",
              "rbe": true,
              "every": 2,
              "script": "-- Robot operation mode\nlocal mode = tonumber(result)\nlocal modes = {\n  [1] = 'Manual',\n  [2] = 'Auto',\n  [3] = 'Remote',\n  [4] = 'Test'\n}\nreturn modes[mode] or 'Unknown'"
            },
            {
              "name": "MotorTemperature",
              "enabled": true,
              "address": "AI.1",
              "rbe": true,
              "every": 3,
              "script": "-- Motor temperature from analog input\nlocal temp = tonumber(result)\nif temp and temp >= 0 and temp <= 150 then\n  return math.floor(temp * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "WorkpieceDetected",
              "enabled": true,
              "address": "UI.1",
              "rbe": true,
              "every": 1,
              "script": "-- Workpiece detection sensor\nlocal detected = result == 1 or result == true\nreturn detected"
            },
            {
              "name": "QualityResult",
              "enabled": true,
              "address": "UI.5",
              "rbe": true,
              "every": 1,
              "script": "-- Quality check result\nlocal passed = result == 1 or result == true\nreturn passed and 'Pass' or 'Fail'"
            },
            {
              "name": "MaintenanceRequired",
              "enabled": true,
              "address": "RDI.1",
              "rbe": true,
              "every": 10,
              "script": "-- Maintenance indicator\nlocal maintenance = result == 1 or result == true\nreturn maintenance and 'Required' or 'OK'"
            },
            {
              "name": "SafetyFence",
              "enabled": true,
              "address": "RDI.5",
              "rbe": true,
              "every": 1,
              "script": "-- Safety fence status\nlocal fenceOK = result == 1 or result == true\nreturn fenceOK and 'Secure' or 'Breached'"
            },
            {
              "name": "PowerConsumption",
              "enabled": true,
              "address": "AI.5",
              "rbe": true,
              "every": 3,
              "script": "-- Power consumption in kW\nlocal power = tonumber(result)\nif power and power >= 0 and power <= 50 then\n  return math.floor(power * 100) / 100\nelse\n  return 0\nend"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "haasShdrSource": {
      "description": "Receives SHDR-like steaming data from a Haas controller over an undocumented port",
      "type": "object",
      "properties": {
        "itemized_read": {
          "type": "boolean",
          "description": "Process incoming data based on items array",
          "default": false
        },
        "address": {
          "type": "string",
          "description": "Controller IP hostname or address"
        },
        "port": {
          "type": "integer",
          "description": "Controller port number",
          "default": 9998
        },
        "timeout": {
          "type": "integer",
          "description": "Connection timeout in milliseconds",
          "default": 1000
        },
        "heartbeat_interval": {
          "type": "integer",
          "description": "Heartbeat frequency in milliseconds",
          "default": 4000
        },
        "retry_interval": {
          "type": "integer",
          "description": "Retry frequency in milliseconds",
          "default": 10000
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "haasVf2",
          "enabled": true,
          "connector": "haasShdr",
          "scan_interval": 500,
          "rbe": true,
          "itemized_read": true,
          "lang_script": "Lua",
          "address": "192.168.1.221",
          "port": 9998,
          "timeout": 1000,
          "heartbeat_interval": 4000,
          "retry_interval": 10000,
          "init_script": "-- Initialize Haas SHDR processing\nprint('Haas SHDR connector initialized')\n-- Define execution state mappings\nExecutionStates = {\n  ['IDLE'] = 'Idle',\n  ['ACTIVE'] = 'Active',\n  ['INTERRUPTED'] = 'Interrupted',\n  ['FEED_HOLD'] = 'Feed_Hold',\n  ['STOPPED'] = 'Stopped'\n}\n-- Define controller mode mappings\nControllerModes = {\n  ['AUTOMATIC'] = 'Automatic',\n  ['MANUAL'] = 'Manual',\n  ['MDI'] = 'Manual_Data_Input',\n  ['JOG'] = 'Jog',\n  ['REFERENCE'] = 'Reference'\n}",
          "enter_script": "-- Log SHDR data collection cycle\n-- print('Haas SHDR data collection started')",
          "exit_script": "-- Calculate spindle utilization\nlocal spindleLoad = cache('./SpindleLoad', 0)\nlocal maxLoad = 100\nif spindleLoad > 0 then\n  local utilization = (spindleLoad / maxLoad) * 100\n  emit('./SpindleUtilization', math.floor(utilization * 10) / 10)\nend",
          "items": [
            {
              "name": "Availability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate machine availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal hasAlarm = cache('./EmergencyStop', 'NORMAL') ~= 'NORMAL'\nif not isConnected then\n  return 'Unavailable'\nelseif hasAlarm then\n  return 'Fault'\nelse\n  return 'Available'\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Availability[category=Event]"
              }
            },
            {
              "name": "Execution",
              "enabled": true,
              "address": "execution",
              "rbe": true,
              "every": 1,
              "script": "-- Map execution state\nlocal state = tostring(result or 'UNAVAILABLE')\nreturn ExecutionStates[state] or state",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/Execution[category=Event]"
              }
            },
            {
              "name": "ControllerMode",
              "enabled": true,
              "address": "mode",
              "rbe": true,
              "every": 1,
              "script": "-- Map controller mode\nlocal mode = tostring(result or 'UNAVAILABLE')\nreturn ControllerModes[mode] or mode",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/ControllerMode[category=Event]"
              }
            },
            {
              "name": "Program",
              "enabled": true,
              "address": "program",
              "rbe": true,
              "every": 2,
              "script": "-- Current program name\nlocal program = tostring(result or '')\nprogram = string.gsub(program, '^%s*(.-)%s*$', '%1')\nreturn program ~= '' and program or 'No_Program'",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/Program[category=Event]"
              }
            },
            {
              "name": "PartCount",
              "enabled": true,
              "address": "partcount",
              "rbe": true,
              "every": 1,
              "script": "-- Total parts produced\nlocal count = tonumber(result)\nif count and count >= 0 and count <= 999999 then\n  return count\nelse\n  return cache('./PartCount', 0)\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/PartCount[category=Event]"
              }
            },
            {
              "name": "SpindleSpeed",
              "enabled": true,
              "address": "Sspeed",
              "rbe": true,
              "every": 1,
              "script": "-- Spindle speed in RPM\nlocal speed = tonumber(result)\nif speed and speed >= 0 and speed <= 10000 then\n  return math.floor(speed)\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/SpindleSpeed[category=Sample]"
              }
            },
            {
              "name": "SpindleLoad",
              "enabled": true,
              "address": "Sload",
              "rbe": true,
              "every": 1,
              "script": "-- Spindle load percentage\nlocal load = tonumber(result)\nif load and load >= 0 and load <= 200 then\n  return math.floor(load * 10) / 10\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/SpindleLoad[category=Sample]"
              }
            },
            {
              "name": "FeedRate",
              "enabled": true,
              "address": "feedrt",
              "rbe": true,
              "every": 1,
              "script": "-- Feed rate in inches per minute\nlocal feed = tonumber(result)\nif feed and feed >= 0 and feed <= 500 then\n  return math.floor(feed * 100) / 100\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/FeedRate[category=Sample]"
              }
            },
            {
              "name": "XPosition",
              "enabled": true,
              "address": "Xabs",
              "rbe": true,
              "every": 1,
              "script": "-- X-axis absolute position\nlocal pos = tonumber(result)\nif pos and pos >= -50 and pos <= 50 then\n  return math.floor(pos * 10000) / 10000\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/Path/XPosition[category=Sample]"
              }
            },
            {
              "name": "YPosition",
              "enabled": true,
              "address": "Yabs",
              "rbe": true,
              "every": 1,
              "script": "-- Y-axis absolute position\nlocal pos = tonumber(result)\nif pos and pos >= -30 and pos <= 30 then\n  return math.floor(pos * 10000) / 10000\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/Path/YPosition[category=Sample]"
              }
            },
            {
              "name": "ZPosition",
              "enabled": true,
              "address": "Zabs",
              "rbe": true,
              "every": 1,
              "script": "-- Z-axis absolute position\nlocal pos = tonumber(result)\nif pos and pos >= -20 and pos <= 5 then\n  return math.floor(pos * 10000) / 10000\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/Path/ZPosition[category=Sample]"
              }
            },
            {
              "name": "ToolNumber",
              "enabled": true,
              "address": "tool",
              "rbe": true,
              "every": 2,
              "script": "-- Current tool number\nlocal tool = tonumber(result)\nif tool and tool >= 0 and tool <= 200 then\n  return tool\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=haas1]/Controller/ToolNumber[category=Event]"
              }
            },
            {
              "name": "Line",
              "enabled": true,
              "address": "line",
              "rbe": true,
              "every": 2,
              "script": "-- Current program line number\nlocal line = tonumber(result)\nif line and line >= 0 then\n  return line\nelse\n  return 0\nend"
            },
            {
              "name": "Block",
              "enabled": true,
              "address": "block",
              "rbe": true,
              "every": 3,
              "script": "-- Current G-code block\nlocal block = tostring(result or '')\nblock = string.gsub(block, '^%s*(.-)%s*$', '%1')\nreturn block ~= '' and block or 'No_Block'"
            },
            {
              "name": "EmergencyStop",
              "enabled": true,
              "address": "estop",
              "rbe": true,
              "every": 1,
              "script": "-- Emergency stop status\nlocal estop = tostring(result or 'NORMAL')\nreturn estop == 'TRIGGERED' and 'Active' or 'Normal'"
            },
            {
              "name": "DoorState",
              "enabled": true,
              "address": "door",
              "rbe": true,
              "every": 1,
              "script": "-- Door state\nlocal door = tostring(result or 'CLOSED')\nreturn door == 'OPEN' and 'Open' or 'Closed'"
            },
            {
              "name": "ChuckState",
              "enabled": true,
              "address": "chuck",
              "rbe": true,
              "every": 2,
              "script": "-- Chuck/workholding state\nlocal chuck = tostring(result or 'OPEN')\nreturn chuck == 'CLOSED' and 'Closed' or 'Open'"
            },
            {
              "name": "CoolantState",
              "enabled": true,
              "address": "coolant",
              "rbe": true,
              "every": 2,
              "script": "-- Coolant status\nlocal coolant = tostring(result or 'OFF')\nreturn coolant == 'ON' and 'On' or 'Off'"
            },
            {
              "name": "FeedOverride",
              "enabled": true,
              "address": "feedovr",
              "rbe": true,
              "every": 2,
              "script": "-- Feed override percentage\nlocal override = tonumber(result)\nif override and override >= 1 and override <= 300 then\n  return override\nelse\n  return 100\nend"
            },
            {
              "name": "SpindleOverride",
              "enabled": true,
              "address": "speedovr",
              "rbe": true,
              "every": 2,
              "script": "-- Spindle override percentage\nlocal override = tonumber(result)\nif override and override >= 1 and override <= 300 then\n  return override\nelse\n  return 100\nend"
            },
            {
              "name": "SystemAlarm",
              "enabled": true,
              "address": "system",
              "rbe": true,
              "every": 1,
              "script": "-- System alarm status\nlocal alarm = tostring(result or 'NORMAL')\nif alarm == 'NORMAL' then\n  return 'Normal'\nelse\n  return 'Alarm: ' .. alarm\nend"
            },
            {
              "name": "PowerState",
              "enabled": true,
              "address": "power",
              "rbe": true,
              "every": 5,
              "script": "-- Power state\nlocal power = tostring(result or 'ON')\nreturn power == 'ON' and 'On' or 'Off'"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "address": "cycletime",
              "rbe": true,
              "every": 1,
              "script": "-- Cycle time in seconds\nlocal time = tonumber(result)\nif time and time > 0 and time < 86400 then\n  return math.floor(time * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "MCode",
              "enabled": true,
              "address": "mcode",
              "rbe": true,
              "every": 2,
              "script": "-- Current M-code\nlocal mcode = tonumber(result)\nif mcode and mcode >= 0 and mcode <= 999 then\n  return 'M' .. string.format('%02d', mcode)\nelse\n  return 'No_MCode'\nend"
            },
            {
              "name": "GCode",
              "enabled": true,
              "address": "gcode",
              "rbe": true,
              "every": 2,
              "script": "-- Current G-code\nlocal gcode = tonumber(result)\nif gcode and gcode >= 0 and gcode <= 999 then\n  return 'G' .. string.format('%02d', gcode)\nelse\n  return 'No_GCode'\nend"
            },
            {
              "name": "CPU",
              "enabled": true,
              "address": "CPU",
              "rbe": true,
              "every": 3,
              "script": "-- CPU usage percentage\nlocal cpu = tonumber(result)\nif cpu and cpu >= 0 and cpu <= 100 then\n  if cpu > 80 then\n    return 'HIGH'\n  elseif cpu > 50 then\n    return 'MEDIUM'\n  else\n    return 'LOW'\n  end\nelse\n  return 'UNKNOWN'\nend"
            }
          ],
          "strip_path_prefix": false,
          "create_dummy_messages_on_startup": true,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "httpServerSource": {
      "description": "Starts an HTTP server and listens to HTTP POST requests",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "URL to listen for POST requests",
          "default": "http://localhost:8081/",
          "pattern": "^https?://.*$"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "httpApiServer",
          "enabled": true,
          "connector": "httpServer",
          "scan_interval": 100,
          "rbe": true,
          "itemized_read": false,
          "lang_script": "Lua",
          "uri": "http://*:8081/",
          "init_script": "-- Initialize HTTP Server for data collection\nprint('HTTP Server connector initialized on port 8081')\n-- Import JSON library for parsing POST data\njson = require('json')\nstringx = require('pl.stringx')\n-- Initialize data validation functions\nfunction validateTemperature(temp)\n  return temp and temp >= -40 and temp <= 150\nend\nfunction validatePressure(pressure)\n  return pressure and pressure >= 0 and pressure <= 1000\nend\nfunction validatePartCount(count)\n  return count and count >= 0 and count <= 999999\nend",
          "enter_script": "-- Log HTTP data collection cycle\n-- print('HTTP Server polling for new requests')",
          "exit_script": "-- Calculate overall system health score\nlocal tempOK = cache('./TemperatureSensor1/status', 'OK') == 'OK'\nlocal pressureOK = cache('./PressureSensor1/status', 'OK') == 'OK'\nlocal productionOK = cache('./ProductionLine1/status', 'Running') == 'Running'\nlocal healthScore = 0\nif tempOK then healthScore = healthScore + 33 end\nif pressureOK then healthScore = healthScore + 33 end\nif productionOK then healthScore = healthScore + 34 end\nemit('./SystemHealth', math.floor(healthScore))",
          "items": [
            {
              "name": "SensorData",
              "enabled": true,
              "address": "api/sensors/data",
              "rbe": true,
              "every": 1,
              "script": "-- Process sensor data from POST requests\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\n-- Extract and validate sensor readings\nlocal sensorId = data.sensorId or 'unknown'\nlocal value = tonumber(data.value)\nlocal timestamp = data.timestamp or os.time()\nlocal sensorType = data.type or 'generic'\n-- Emit individual sensor readings\nif value then\n  emit('./Sensor_' .. sensorId, value)\n  emit('./Sensor_' .. sensorId .. '/timestamp', timestamp)\n  emit('./Sensor_' .. sensorId .. '/type', sensorType)\nend\n-- Return summary for this item\nreturn sensorId .. ': ' .. (value or 'invalid')"
            },
            {
              "name": "TemperatureSensor1",
              "enabled": true,
              "address": "api/temperature/sensor1",
              "rbe": true,
              "every": 1,
              "script": "-- Process temperature sensor data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal temp = tonumber(data.temperature)\nlocal unit = data.unit or 'C'\nlocal location = data.location or 'unknown'\n-- Validate temperature reading\nif validateTemperature(temp) then\n  emit('./TemperatureSensor1/value', temp)\n  emit('./TemperatureSensor1/unit', unit)\n  emit('./TemperatureSensor1/location', location)\n  emit('./TemperatureSensor1/status', 'OK')\n  return temp\nelse\n  emit('./TemperatureSensor1/status', 'Error')\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=factory1]/Controller/Temperature[category=Sample]"
              }
            },
            {
              "name": "PressureSensor1",
              "enabled": true,
              "address": "api/pressure/sensor1",
              "rbe": true,
              "every": 1,
              "script": "-- Process pressure sensor data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal pressure = tonumber(data.pressure)\nlocal unit = data.unit or 'PSI'\nlocal system = data.system or 'hydraulic'\n-- Validate pressure reading\nif validatePressure(pressure) then\n  emit('./PressureSensor1/value', pressure)\n  emit('./PressureSensor1/unit', unit)\n  emit('./PressureSensor1/system', system)\n  emit('./PressureSensor1/status', 'OK')\n  return pressure\nelse\n  emit('./PressureSensor1/status', 'Error')\n  return nil\nend"
            },
            {
              "name": "ProductionLine1",
              "enabled": true,
              "address": "api/production/line1",
              "rbe": true,
              "every": 1,
              "script": "-- Process production line data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal status = data.status or 'Unknown'\nlocal partCount = tonumber(data.partCount)\nlocal cycleTime = tonumber(data.cycleTime)\nlocal operator = data.operator or 'Unknown'\n-- Emit production metrics\nemit('./ProductionLine1/status', status)\nif validatePartCount(partCount) then\n  emit('./ProductionLine1/partCount', partCount)\nend\nif cycleTime and cycleTime > 0 and cycleTime < 600 then\n  emit('./ProductionLine1/cycleTime', cycleTime)\nend\nemit('./ProductionLine1/operator', operator)\n-- Return status summary\nreturn status .. ' - Parts: ' .. (partCount or 'N/A')"
            },
            {
              "name": "QualityData",
              "enabled": true,
              "address": "api/quality/inspection",
              "rbe": true,
              "every": 1,
              "script": "-- Process quality inspection data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal inspectionId = data.inspectionId or 'unknown'\nlocal result_status = data.result or 'Unknown'\nlocal defectCount = tonumber(data.defectCount) or 0\nlocal inspector = data.inspector or 'Auto'\nlocal timestamp = data.timestamp or os.time()\n-- Emit quality metrics\nemit('./QualityData/inspectionId', inspectionId)\nemit('./QualityData/result', result_status)\nemit('./QualityData/defectCount', defectCount)\nemit('./QualityData/inspector', inspector)\nemit('./QualityData/timestamp', timestamp)\n-- Calculate pass/fail\nlocal passed = result_status == 'PASS' or defectCount == 0\nreturn passed and 'Pass' or 'Fail'"
            },
            {
              "name": "AlarmNotification",
              "enabled": true,
              "address": "api/alarms/notify",
              "rbe": false,
              "every": 1,
              "script": "-- Process alarm notifications\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal alarmId = data.alarmId or 'unknown'\nlocal severity = data.severity or 'INFO'\nlocal message = data.message or 'No message'\nlocal source = data.source or 'unknown'\nlocal timestamp = data.timestamp or os.time()\n-- Format alarm message\nlocal formattedAlarm = '[' .. severity .. '] ' .. source .. ': ' .. message\n-- Emit alarm details\nemit('./AlarmNotification/alarmId', alarmId)\nemit('./AlarmNotification/severity', severity)\nemit('./AlarmNotification/source', source)\nemit('./AlarmNotification/timestamp', timestamp)\nreturn formattedAlarm"
            },
            {
              "name": "MaintenanceRequest",
              "enabled": true,
              "address": "api/maintenance/request",
              "rbe": true,
              "every": 1,
              "script": "-- Process maintenance requests\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal equipmentId = data.equipmentId or 'unknown'\nlocal requestType = data.requestType or 'unknown'\nlocal priority = data.priority or 'LOW'\nlocal description = data.description or 'No description'\nlocal requestedBy = data.requestedBy or 'System'\n-- Emit maintenance details\nemit('./MaintenanceRequest/equipmentId', equipmentId)\nemit('./MaintenanceRequest/requestType', requestType)\nemit('./MaintenanceRequest/priority', priority)\nemit('./MaintenanceRequest/requestedBy', requestedBy)\n-- Return formatted request\nreturn equipmentId .. ' - ' .. requestType .. ' (' .. priority .. ')'"
            },
            {
              "name": "EnergyMonitor",
              "enabled": true,
              "address": "api/energy/consumption",
              "rbe": true,
              "every": 1,
              "script": "-- Process energy consumption data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal meterId = data.meterId or 'unknown'\nlocal powerKW = tonumber(data.powerKW)\nlocal voltageV = tonumber(data.voltageV)\nlocal currentA = tonumber(data.currentA)\nlocal energyKWh = tonumber(data.energyKWh)\n-- Validate and emit energy metrics\nif powerKW and powerKW >= 0 and powerKW <= 1000 then\n  emit('./EnergyMonitor/' .. meterId .. '/power', powerKW)\nend\nif voltageV and voltageV >= 0 and voltageV <= 600 then\n  emit('./EnergyMonitor/' .. meterId .. '/voltage', voltageV)\nend\nif currentA and currentA >= 0 and currentA <= 500 then\n  emit('./EnergyMonitor/' .. meterId .. '/current', currentA)\nend\nif energyKWh and energyKWh >= 0 then\n  emit('./EnergyMonitor/' .. meterId .. '/energy', energyKWh)\nend\nreturn meterId .. ': ' .. (powerKW or 'N/A') .. ' kW'"
            },
            {
              "name": "InventoryUpdate",
              "enabled": true,
              "address": "api/inventory/update",
              "rbe": true,
              "every": 1,
              "script": "-- Process inventory updates\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal partNumber = data.partNumber or 'unknown'\nlocal quantity = tonumber(data.quantity)\nlocal location = data.location or 'unknown'\nlocal operation = data.operation or 'unknown'\nlocal timestamp = data.timestamp or os.time()\n-- Emit inventory details\nemit('./InventoryUpdate/' .. partNumber .. '/quantity', quantity or 0)\nemit('./InventoryUpdate/' .. partNumber .. '/location', location)\nemit('./InventoryUpdate/' .. partNumber .. '/operation', operation)\nemit('./InventoryUpdate/' .. partNumber .. '/timestamp', timestamp)\n-- Return formatted update\nreturn partNumber .. ': ' .. (quantity or 0) .. ' @ ' .. location"
            },
            {
              "name": "OperatorMessage",
              "enabled": true,
              "address": "api/operator/message",
              "rbe": true,
              "every": 1,
              "script": "-- Process operator messages\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal operatorId = data.operatorId or 'unknown'\nlocal message = data.message or 'No message'\nlocal station = data.station or 'unknown'\nlocal priority = data.priority or 'NORMAL'\nlocal timestamp = data.timestamp or os.time()\n-- Clean and format message\nmessage = string.gsub(message, '^%s*(.-)%s*$', '%1')\n-- Emit operator communication\nemit('./OperatorMessage/operatorId', operatorId)\nemit('./OperatorMessage/station', station)\nemit('./OperatorMessage/priority', priority)\nemit('./OperatorMessage/timestamp', timestamp)\nreturn '[' .. operatorId .. '] ' .. message"
            },
            {
              "name": "BatchTracker",
              "enabled": true,
              "address": "api/batch/tracking",
              "rbe": true,
              "every": 1,
              "script": "-- Process batch tracking data\nif not result or result == '' then\n  return nil\nend\nlocal data = json.decode(result)\nif not data then\n  return nil\nend\nlocal batchId = data.batchId or 'unknown'\nlocal status = data.status or 'unknown'\nlocal progress = tonumber(data.progress) or 0\nlocal startTime = data.startTime\nlocal estimatedCompletion = data.estimatedCompletion\n-- Emit batch tracking details\nemit('./BatchTracker/' .. batchId .. '/status', status)\nemit('./BatchTracker/' .. batchId .. '/progress', progress)\nif startTime then\n  emit('./BatchTracker/' .. batchId .. '/startTime', startTime)\nend\nif estimatedCompletion then\n  emit('./BatchTracker/' .. batchId .. '/estimatedCompletion', estimatedCompletion)\nend\nreturn batchId .. ': ' .. status .. ' (' .. progress .. '%)'"
            },
            {
              "name": "GenericWebhook",
              "enabled": true,
              "address": "webhook/generic",
              "rbe": false,
              "every": 1,
              "script": "-- Process generic webhook data\nif not result or result == '' then\n  return nil\nend\n-- Try to parse as JSON, fallback to raw text\nlocal success, data = pcall(json.decode, result)\nif success and data then\n  -- JSON payload\n  local source = data.source or 'webhook'\n  local event = data.event or 'generic'\n  local payload = data.payload or data\n  emit('./GenericWebhook/source', source)\n  emit('./GenericWebhook/event', event)\n  return source .. ': ' .. event\nelse\n  -- Raw text payload\n  local cleanData = string.gsub(result, '^%s*(.-)%s*$', '%1')\n  return 'Raw: ' .. string.sub(cleanData, 1, 100)\nend"
            }
          ],
          "strip_path_prefix": false,
          "create_dummy_messages_on_startup": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "jsonWebScraperSource": {
      "description": "Reads data from a JSON web page",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Web page address",
          "default": "http://localhost/"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "jsonApiScraper",
          "enabled": true,
          "connector": "jsonWebScraper",
          "scan_interval": 5000,
          "rbe": true,
          "lang_script": "Lua",
          "uri": "https://api.factory-iot.example.com/v1/status",
          "init_script": "-- Initialize JSON Web Scraper\nprint('JSON Web Scraper connector initialized')\n-- Import JSON library for additional processing\njson = require('json')\nstringx = require('pl.stringx')\n-- Define data validation functions\nfunction validateTemperature(temp)\n  return temp and temp >= -50 and temp <= 200\nend\nfunction validatePercentage(pct)\n  return pct and pct >= 0 and pct <= 100\nend\nfunction formatTimestamp(ts)\n  if ts then\n    return os.date('%Y-%m-%d %H:%M:%S', ts)\n  else\n    return 'Unknown'\n  end\nend",
          "enter_script": "-- Log scraping cycle start\n-- print('Starting JSON data scraping cycle')",
          "exit_script": "-- Calculate overall facility efficiency\nlocal line1Eff = cache('./ProductionLine1/efficiency', 0)\nlocal line2Eff = cache('./ProductionLine2/efficiency', 0)\nlocal line3Eff = cache('./ProductionLine3/efficiency', 0)\nlocal avgEfficiency = (line1Eff + line2Eff + line3Eff) / 3\nemit('./FacilityEfficiency', math.floor(avgEfficiency * 10) / 10)",
          "items": [
            {
              "name": "SystemStatus",
              "enabled": true,
              "address": "$.system.status",
              "rbe": true,
              "every": 1,
              "script": "-- Process overall system status\nlocal status = tostring(result or 'Unknown')\nlocal statusMap = {\n  ['online'] = 'Online',\n  ['offline'] = 'Offline',\n  ['maintenance'] = 'Maintenance',\n  ['error'] = 'Error'\n}\nreturn statusMap[string.lower(status)] or status"
            },
            {
              "name": "ProductionLine1",
              "enabled": true,
              "address": "$.production.lines[0]",
              "rbe": true,
              "every": 1,
              "script": "-- Process production line 1 data\nif not result then return nil end\nlocal line = json.decode(result)\nif not line then return nil end\n-- Extract line data\nlocal lineId = line.id or 'Line1'\nlocal status = line.status or 'Unknown'\nlocal output = tonumber(line.currentOutput) or 0\nlocal target = tonumber(line.targetOutput) or 1\nlocal efficiency = math.floor((output / target) * 100 * 10) / 10\nlocal operator = line.operator or 'Unknown'\n-- Emit individual metrics\nemit('./ProductionLine1/status', status)\nemit('./ProductionLine1/output', output)\nemit('./ProductionLine1/target', target)\nemit('./ProductionLine1/efficiency', efficiency)\nemit('./ProductionLine1/operator', operator)\nreturn status .. ' - ' .. output .. '/' .. target .. ' (' .. efficiency .. '%)'",
              "sink": {
                "mtconnect": "Device[name=line1]/Controller/Execution[category=Event]"
              }
            },
            {
              "name": "ProductionLine2",
              "enabled": true,
              "address": "$.production.lines[1]",
              "rbe": true,
              "every": 1,
              "script": "-- Process production line 2 data\nif not result then return nil end\nlocal line = json.decode(result)\nif not line then return nil end\n-- Extract and validate data\nlocal status = line.status or 'Unknown'\nlocal output = tonumber(line.currentOutput) or 0\nlocal target = tonumber(line.targetOutput) or 1\nlocal efficiency = math.floor((output / target) * 100 * 10) / 10\n-- Emit metrics\nemit('./ProductionLine2/status', status)\nemit('./ProductionLine2/output', output)\nemit('./ProductionLine2/efficiency', efficiency)\nreturn status .. ' - Efficiency: ' .. efficiency .. '%'"
            },
            {
              "name": "ProductionLine3",
              "enabled": true,
              "address": "$.production.lines[2]",
              "rbe": true,
              "every": 1,
              "script": "-- Process production line 3 data\nif not result then return nil end\nlocal line = json.decode(result)\nif not line then return nil end\n-- Extract data\nlocal status = line.status or 'Unknown'\nlocal output = tonumber(line.currentOutput) or 0\nlocal target = tonumber(line.targetOutput) or 1\nlocal efficiency = math.floor((output / target) * 100 * 10) / 10\n-- Emit metrics\nemit('./ProductionLine3/status', status)\nemit('./ProductionLine3/output', output)\nemit('./ProductionLine3/efficiency', efficiency)\nreturn status .. ' - Output: ' .. output"
            },
            {
              "name": "EnvironmentalData",
              "enabled": true,
              "address": "$.environment",
              "rbe": true,
              "every": 2,
              "script": "-- Process environmental sensor data\nif not result then return nil end\nlocal env = json.decode(result)\nif not env then return nil end\n-- Extract environmental metrics\nlocal temperature = tonumber(env.temperature)\nlocal humidity = tonumber(env.humidity)\nlocal airQuality = env.airQuality or 'Unknown'\nlocal co2Level = tonumber(env.co2Level)\n-- Validate and emit data\nif validateTemperature(temperature) then\n  emit('./EnvironmentalData/temperature', temperature)\nend\nif validatePercentage(humidity) then\n  emit('./EnvironmentalData/humidity', humidity)\nend\nemit('./EnvironmentalData/airQuality', airQuality)\nif co2Level and co2Level >= 0 and co2Level <= 5000 then\n  emit('./EnvironmentalData/co2Level', co2Level)\nend\nreturn 'Temp: ' .. (temperature or 'N/A') .. '°C, Humidity: ' .. (humidity or 'N/A') .. '%'"
            },
            {
              "name": "EnergyConsumption",
              "enabled": true,
              "address": "$.energy.totalConsumption",
              "rbe": true,
              "every": 3,
              "script": "-- Process total energy consumption\nlocal consumption = tonumber(result)\nif consumption and consumption >= 0 and consumption <= 10000 then\n  return math.floor(consumption * 100) / 100\nelse\n  return cache('./EnergyConsumption', 0)\nend"
            },
            {
              "name": "QualityMetrics",
              "enabled": true,
              "address": "$.quality",
              "rbe": true,
              "every": 2,
              "script": "-- Process quality metrics\nif not result then return nil end\nlocal quality = json.decode(result)\nif not quality then return nil end\n-- Extract quality data\nlocal passRate = tonumber(quality.passRate) or 0\nlocal defectRate = tonumber(quality.defectRate) or 0\nlocal totalInspected = tonumber(quality.totalInspected) or 0\nlocal lastInspection = quality.lastInspectionTime\n-- Emit quality metrics\nemit('./QualityMetrics/passRate', passRate)\nemit('./QualityMetrics/defectRate', defectRate)\nemit('./QualityMetrics/totalInspected', totalInspected)\nif lastInspection then\n  emit('./QualityMetrics/lastInspection', lastInspection)\nend\nreturn 'Pass Rate: ' .. passRate .. '%, Defects: ' .. defectRate .. '%'"
            },
            {
              "name": "ActiveAlarms",
              "enabled": true,
              "address": "$.alarms[*].{id: id, severity: severity, message: message}",
              "rbe": false,
              "every": 1,
              "script": "-- Process active alarms array\nif not result then return nil end\nlocal alarms = json.decode(result)\nif not alarms or type(alarms) ~= 'table' then return nil end\n-- Process each alarm\nlocal alarmCount = 0\nlocal highPriorityCount = 0\nfor i, alarm in ipairs(alarms) do\n  if alarm.id then\n    alarmCount = alarmCount + 1\n    local severity = string.upper(alarm.severity or 'LOW')\n    if severity == 'HIGH' or severity == 'CRITICAL' then\n      highPriorityCount = highPriorityCount + 1\n    end\n    -- Emit individual alarm\n    emit('./ActiveAlarms/alarm_' .. alarm.id, alarm.message or 'No message')\n    emit('./ActiveAlarms/alarm_' .. alarm.id .. '_severity', severity)\n  end\nend\n-- Emit summary metrics\nemit('./ActiveAlarms/totalCount', alarmCount)\nemit('./ActiveAlarms/highPriorityCount', highPriorityCount)\nreturn 'Total: ' .. alarmCount .. ', High Priority: ' .. highPriorityCount"
            },
            {
              "name": "MaintenanceSchedule",
              "enabled": true,
              "address": "$.maintenance.nextScheduled",
              "rbe": true,
              "every": 10,
              "script": "-- Process next maintenance schedule\nif not result then return nil end\nlocal maintenance = json.decode(result)\nif not maintenance then return nil end\n-- Extract maintenance info\nlocal equipmentId = maintenance.equipmentId or 'Unknown'\nlocal maintenanceType = maintenance.type or 'Unknown'\nlocal scheduledDate = maintenance.scheduledDate\nlocal daysUntil = tonumber(maintenance.daysUntil)\n-- Format response\nlocal response = equipmentId .. ' - ' .. maintenanceType\nif daysUntil then\n  response = response .. ' (in ' .. daysUntil .. ' days)'\nend\nreturn response"
            },
            {
              "name": "InventoryLevels",
              "enabled": true,
              "address": "$.inventory.rawMaterials[*].{partNumber: partNumber, quantity: currentQuantity, minimum: minimumLevel}",
              "rbe": true,
              "every": 5,
              "script": "-- Process inventory levels\nif not result then return nil end\nlocal inventory = json.decode(result)\nif not inventory or type(inventory) ~= 'table' then return nil end\n-- Process inventory items\nlocal lowStockCount = 0\nlocal totalItems = 0\nfor i, item in ipairs(inventory) do\n  if item.partNumber then\n    totalItems = totalItems + 1\n    local quantity = tonumber(item.quantity) or 0\n    local minimum = tonumber(item.minimum) or 0\n    -- Check for low stock\n    if quantity <= minimum then\n      lowStockCount = lowStockCount + 1\n    end\n    -- Emit individual item levels\n    emit('./InventoryLevels/' .. item.partNumber, quantity)\n    emit('./InventoryLevels/' .. item.partNumber .. '_status', quantity <= minimum and 'Low' or 'OK')\n  end\nend\n-- Emit summary\nemit('./InventoryLevels/totalItems', totalItems)\nemit('./InventoryLevels/lowStockCount', lowStockCount)\nreturn 'Items: ' .. totalItems .. ', Low Stock: ' .. lowStockCount"
            },
            {
              "name": "OperatorShift",
              "enabled": true,
              "address": "$.workforce.currentShift",
              "rbe": true,
              "every": 5,
              "script": "-- Process current shift information\nif not result then return nil end\nlocal shift = json.decode(result)\nif not shift then return nil end\n-- Extract shift data\nlocal shiftName = shift.name or 'Unknown'\nlocal supervisor = shift.supervisor or 'Unknown'\nlocal operatorCount = tonumber(shift.operatorCount) or 0\nlocal startTime = shift.startTime\nlocal endTime = shift.endTime\n-- Emit shift details\nemit('./OperatorShift/name', shiftName)\nemit('./OperatorShift/supervisor', supervisor)\nemit('./OperatorShift/operatorCount', operatorCount)\nif startTime then\n  emit('./OperatorShift/startTime', startTime)\nend\nif endTime then\n  emit('./OperatorShift/endTime', endTime)\nend\nreturn shiftName .. ' - ' .. supervisor .. ' (' .. operatorCount .. ' operators)'"
            },
            {
              "name": "WeatherData",
              "enabled": true,
              "address": "$.weather",
              "rbe": true,
              "every": 15,
              "script": "-- Process weather data for outdoor operations\nif not result then return nil end\nlocal weather = json.decode(result)\nif not weather then return nil end\n-- Extract weather information\nlocal temperature = tonumber(weather.temperature)\nlocal humidity = tonumber(weather.humidity)\nlocal windSpeed = tonumber(weather.windSpeed)\nlocal conditions = weather.conditions or 'Unknown'\n-- Emit weather data\nif temperature then\n  emit('./WeatherData/temperature', temperature)\nend\nif humidity then\n  emit('./WeatherData/humidity', humidity)\nend\nif windSpeed then\n  emit('./WeatherData/windSpeed', windSpeed)\nend\nemit('./WeatherData/conditions', conditions)\nreturn conditions .. ' - ' .. (temperature or 'N/A') .. '°C'"
            },
            {
              "name": "ProductionTargets",
              "enabled": true,
              "address": "$.targets.daily",
              "rbe": true,
              "every": 10,
              "script": "-- Process daily production targets\nif not result then return nil end\nlocal targets = json.decode(result)\nif not targets then return nil end\n-- Extract target information\nlocal totalTarget = tonumber(targets.total) or 0\nlocal currentProgress = tonumber(targets.currentProgress) or 0\nlocal percentComplete = totalTarget > 0 and (currentProgress / totalTarget * 100) or 0\nlocal hoursRemaining = tonumber(targets.hoursRemaining) or 0\n-- Emit target metrics\nemit('./ProductionTargets/total', totalTarget)\nemit('./ProductionTargets/currentProgress', currentProgress)\nemit('./ProductionTargets/percentComplete', math.floor(percentComplete * 10) / 10)\nemit('./ProductionTargets/hoursRemaining', hoursRemaining)\nreturn currentProgress .. '/' .. totalTarget .. ' (' .. math.floor(percentComplete) .. '%)'",
              "sink": {
                "mtconnect": "Device[name=factory1]/Controller/PartCount[category=Event]"
              }
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "modbusTcpSource": {
      "description": "Reads data from a Modbus/TCP device",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Device hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Port number",
          "default": 502
        },
        "slave": {
          "type": "integer",
          "description": "Modbus slave ID",
          "default": 1
        },
        "timeout": {
          "type": "integer",
          "description": "Read timeout in milliseconds",
          "default": 1000
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/modbusTcpItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "myUniqueConnectorName",
          "enabled": true,
          "connector": "modbusTcp",
          "scan_interval": 1000,
          "address": "192.168.1.50",
          "port": 502,
          "slave": 1,
          "timeout": 2000,
          "items": [
            {
              "name": "HoldingRegister1",
              "enabled": true,
              "address": 1,
              "rbe": true,
              "every": 1
            }
          ]
        },
        {
          "name": "modbusDevice1",
          "enabled": true,
          "connector": "modbusTcp",
          "scan_interval": 2000,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.50",
          "port": 502,
          "slave": 1,
          "timeout": 2000,
          "init_script": "-- Initialize Modbus TCP processing\nprint('Modbus TCP connector initialized')\n-- Import struct library for multi-register processing\nstruct = require('struct')\n-- Define register type mappings\nRegisterTypes = {\n  [1] = 'Coil',\n  [2] = 'Input',\n  [3] = 'Holding',\n  [4] = 'Input_Register'\n}\n-- Define alarm state mappings\nAlarmStates = {\n  [0] = 'Normal',\n  [1] = 'Warning',\n  [2] = 'Alarm',\n  [3] = 'Critical'\n}\n-- Data validation functions\nfunction validateTemperature(temp)\n  return temp and temp >= -40 and temp <= 150\nend\nfunction validatePressure(pressure)\n  return pressure and pressure >= 0 and pressure <= 1000\nend",
          "enter_script": "-- Log Modbus read cycle start\n-- print('Starting Modbus TCP read cycle')",
          "exit_script": "-- Calculate overall equipment effectiveness\nlocal isRunning = cache('./SystemRunning', false)\nlocal quality = cache('./QualityRate', 100)\nlocal availability = cache('./SystemAvailable', false)\nlocal performance = cache('./PerformanceRate', 100)\nif isRunning and availability then\n  local oee = (quality * performance) / 10000\n  emit('./OverallEquipmentEffectiveness', math.floor(oee * 100) / 100)\nend",
          "items": [
            {
              "name": "SystemAvailability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate system availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal systemRunning = cache('./SystemRunning', false)\nlocal hasAlarms = cache('./AlarmStatus', 0) > 0\nif not isConnected then\n  return 'Unavailable'\nelseif hasAlarms then\n  return 'Fault'\nelseif systemRunning then\n  return 'Available'\nelse\n  return 'Stopped'\nend",
              "sink": {
                "mtconnect": "Device[name=modbus1]/Availability[category=Event]"
              }
            },
            {
              "name": "SystemRunning",
              "enabled": true,
              "type": 1,
              "address": 1,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- System running status from coil\nlocal running = result and result[1] == 1\nreturn running"
            },
            {
              "name": "EmergencyStop",
              "enabled": true,
              "type": 1,
              "address": 2,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- Emergency stop status (normally closed)\nlocal estop = result and result[1] == 0\nreturn estop and 'Activated' or 'Normal'"
            },
            {
              "name": "MotorStatus",
              "enabled": true,
              "type": 1,
              "address": 10,
              "count": 8,
              "rbe": true,
              "every": 2,
              "script": "-- Process multiple motor status bits\nif not result or #result < 8 then return nil end\nlocal motors = {}\nfor i = 1, 8 do\n  local motorRunning = result[i] == 1\n  motors[i] = motorRunning and 'Running' or 'Stopped'\n  emit('./Motor' .. i .. 'Status', motors[i])\nend\n-- Count running motors\nlocal runningCount = 0\nfor i = 1, 8 do\n  if result[i] == 1 then runningCount = runningCount + 1 end\nend\nreturn runningCount .. '/8 motors running'"
            },
            {
              "name": "InputSignals",
              "enabled": true,
              "type": 2,
              "address": 1,
              "count": 16,
              "rbe": true,
              "every": 2,
              "script": "-- Process digital input signals\nif not result or #result < 16 then return nil end\n-- Define input meanings\nlocal inputNames = {\n  'Door_Closed', 'Safety_OK', 'Part_Present', 'Tool_Ready',\n  'Coolant_Level_OK', 'Air_Pressure_OK', 'Hydraulic_OK', 'Conveyor_Ready',\n  'Quality_Gate_Pass', 'Maintenance_Required', 'Operator_Present', 'Cycle_Start',\n  'Home_Position', 'Jog_Enable', 'Manual_Mode', 'Auto_Mode'\n}\n-- Emit individual input states\nlocal activeInputs = 0\nfor i = 1, 16 do\n  local inputActive = result[i] == 1\n  local inputName = inputNames[i] or ('Input_' .. i)\n  emit('./InputSignals/' .. inputName, inputActive)\n  if inputActive then activeInputs = activeInputs + 1 end\nend\nreturn activeInputs .. ' active inputs'"
            },
            {
              "name": "PartCount",
              "enabled": true,
              "type": 3,
              "address": 100,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- Parts produced count\nlocal count = result and result[1] or 0\nif count >= 0 and count <= 999999 then\n  return count\nelse\n  return cache('./PartCount', 0)\nend",
              "sink": {
                "mtconnect": "Device[name=modbus1]/Controller/PartCount[category=Event]"
              }
            },
            {
              "name": "RejectCount",
              "enabled": true,
              "type": 3,
              "address": 101,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- Rejected parts count\nlocal rejects = result and result[1] or 0\nif rejects >= 0 then\n  return rejects\nelse\n  return cache('./RejectCount', 0)\nend"
            },
            {
              "name": "SetPoint",
              "enabled": true,
              "type": 3,
              "address": 200,
              "count": 1,
              "rbe": true,
              "every": 3,
              "script": "-- Process setpoint value (scaled)\nlocal setpoint = result and result[1] or 0\n-- Convert from raw value to engineering units\nlocal engineeringValue = setpoint / 10.0\nif engineeringValue >= 0 and engineeringValue <= 6553.5 then\n  return math.floor(engineeringValue * 10) / 10\nelse\n  return 0\nend"
            },
            {
              "name": "AlarmStatus",
              "enabled": true,
              "type": 3,
              "address": 300,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- Process alarm status register\nlocal alarmWord = result and result[1] or 0\nlocal alarmCount = 0\n-- Check individual alarm bits\nlocal alarmNames = {\n  'Temperature_High', 'Pressure_Low', 'Vibration_High', 'Oil_Level_Low',\n  'Overload', 'Communication_Error', 'Power_Supply_Fault', 'Safety_Circuit',\n  'Tool_Wear', 'Cycle_Time_Exceeded', 'Quality_Fail', 'Maintenance_Due',\n  'Emergency_Stop', 'Door_Open', 'Air_Pressure_Low', 'Reserved'\n}\nfor bit = 0, 15 do\n  local alarmActive = (alarmWord & (1 << bit)) ~= 0\n  local alarmName = alarmNames[bit + 1] or ('Alarm_Bit_' .. bit)\n  emit('./AlarmStatus/' .. alarmName, alarmActive)\n  if alarmActive then alarmCount = alarmCount + 1 end\nend\nreturn alarmCount"
            },
            {
              "name": "Temperature32Bit",
              "enabled": true,
              "type": 3,
              "address": 400,
              "count": 2,
              "rbe": true,
              "every": 2,
              "script": "-- Process 32-bit temperature value (IEEE 754 float)\nif not result or #result < 2 then return nil end\n-- Convert two 16-bit registers to 32-bit float\nlocal temp = struct.unpack('<f', struct.pack('<HH', result[1], result[2]))\nif validateTemperature(temp) then\n  return math.floor(temp * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=modbus1]/Controller/Temperature[category=Sample]"
              }
            },
            {
              "name": "Pressure32Bit",
              "enabled": true,
              "type": 3,
              "address": 402,
              "count": 2,
              "rbe": true,
              "every": 2,
              "script": "-- Process 32-bit pressure value\nif not result or #result < 2 then return nil end\n-- Convert to 32-bit unsigned integer, then scale\nlocal pressureRaw = struct.unpack('<I', struct.pack('<HH', result[1], result[2]))\nlocal pressure = pressureRaw / 1000.0  -- Scale to PSI\nif validatePressure(pressure) then\n  return math.floor(pressure * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "VibrationXYZ",
              "enabled": true,
              "type": 3,
              "address": 500,
              "count": 3,
              "rbe": true,
              "every": 2,
              "script": "-- Process XYZ vibration readings\nif not result or #result < 3 then return nil end\n-- Extract and scale vibration values\nlocal vibX = (result[1] - 32768) / 1000.0  -- Convert to signed, scale to g\nlocal vibY = (result[2] - 32768) / 1000.0\nlocal vibZ = (result[3] - 32768) / 1000.0\n-- Emit individual axis values\nemit('./VibrationXYZ/X', math.floor(vibX * 1000) / 1000)\nemit('./VibrationXYZ/Y', math.floor(vibY * 1000) / 1000)\nemit('./VibrationXYZ/Z', math.floor(vibZ * 1000) / 1000)\n-- Calculate magnitude\nlocal magnitude = math.sqrt(vibX*vibX + vibY*vibY + vibZ*vibZ)\nreturn math.floor(magnitude * 1000) / 1000"
            },
            {
              "name": "SpeedFeedback",
              "enabled": true,
              "type": 4,
              "address": 1,
              "count": 1,
              "rbe": true,
              "every": 1,
              "script": "-- Motor speed feedback from input register\nlocal speedRaw = result and result[1] or 0\n-- Convert to RPM (assuming 0-65535 maps to 0-3000 RPM)\nlocal speedRPM = (speedRaw / 65535.0) * 3000\nif speedRPM >= 0 and speedRPM <= 3000 then\n  return math.floor(speedRPM)\nelse\n  return 0\nend",
              "sink": {
                "mtconnect": "Device[name=modbus1]/Controller/SpindleSpeed[category=Sample]"
              }
            },
            {
              "name": "PowerConsumption",
              "enabled": true,
              "type": 4,
              "address": 10,
              "count": 1,
              "rbe": true,
              "every": 3,
              "script": "-- Power consumption in watts\nlocal powerRaw = result and result[1] or 0\n-- Scale to watts (0-65535 maps to 0-50000W)\nlocal powerWatts = (powerRaw / 65535.0) * 50000\nif powerWatts >= 0 and powerWatts <= 50000 then\n  return math.floor(powerWatts)\nelse\n  return 0\nend"
            },
            {
              "name": "FlowRate",
              "enabled": true,
              "type": 4,
              "address": 20,
              "count": 1,
              "rbe": true,
              "every": 2,
              "script": "-- Coolant flow rate\nlocal flowRaw = result and result[1] or 0\n-- Convert to GPM (gallons per minute)\nlocal flowGPM = (flowRaw / 65535.0) * 100\nif flowGPM >= 0 and flowGPM <= 100 then\n  return math.floor(flowGPM * 10) / 10\nelse\n  return 0\nend"
            },
            {
              "name": "AnalogInputs",
              "enabled": true,
              "type": 4,
              "address": 100,
              "count": 8,
              "rbe": true,
              "every": 3,
              "script": "-- Process multiple analog inputs\nif not result or #result < 8 then return nil end\n-- Define analog input purposes\nlocal inputNames = {\n  'Tank_Level', 'Oil_Pressure', 'Air_Pressure', 'Hydraulic_Pressure',\n  'Spindle_Load', 'Feed_Force', 'Clamp_Pressure', 'Conveyor_Speed'\n}\n-- Process each analog input\nlocal analogSummary = {}\nfor i = 1, 8 do\n  local rawValue = result[i]\n  local scaledValue = (rawValue / 65535.0) * 100  -- Scale to 0-100%\n  local inputName = inputNames[i] or ('Analog_' .. i)\n  emit('./AnalogInputs/' .. inputName, math.floor(scaledValue * 10) / 10)\n  analogSummary[i] = math.floor(scaledValue)\nend\nreturn table.concat(analogSummary, ',')"
            },
            {
              "name": "QualityMetrics",
              "enabled": true,
              "type": 3,
              "address": 600,
              "count": 4,
              "rbe": true,
              "every": 5,
              "script": "-- Process quality metrics\nif not result or #result < 4 then return nil end\n-- Extract quality data\nlocal totalParts = result[1] or 0\nlocal goodParts = result[2] or 0\nlocal rejectParts = result[3] or 0\nlocal reworkParts = result[4] or 0\n-- Calculate quality metrics\nlocal qualityRate = totalParts > 0 and (goodParts / totalParts * 100) or 100\nlocal rejectRate = totalParts > 0 and (rejectParts / totalParts * 100) or 0\nlocal reworkRate = totalParts > 0 and (reworkParts / totalParts * 100) or 0\n-- Emit quality metrics\nemit('./QualityMetrics/totalParts', totalParts)\nemit('./QualityMetrics/goodParts', goodParts)\nemit('./QualityMetrics/qualityRate', math.floor(qualityRate * 10) / 10)\nemit('./QualityMetrics/rejectRate', math.floor(rejectRate * 10) / 10)\nemit('./QualityMetrics/reworkRate', math.floor(reworkRate * 10) / 10)\nreturn 'Quality: ' .. math.floor(qualityRate) .. '%, Rejects: ' .. math.floor(rejectRate) .. '%'"
            },
            {
              "name": "ProcessParameters",
              "enabled": true,
              "type": 3,
              "address": 700,
              "count": 6,
              "rbe": true,
              "every": 2,
              "script": "-- Process control parameters\nif not result or #result < 6 then return nil end\n-- Extract process parameters (scaled values)\nlocal feedRate = result[1] / 10.0  -- Feed rate in IPM\nlocal spindleSpeed = result[2]      -- Spindle speed in RPM\nlocal cutDepth = result[3] / 1000.0 -- Cut depth in inches\nlocal toolLife = result[4]          -- Tool life percentage\nlocal cycleTime = result[5] / 10.0  -- Cycle time in seconds\nlocal coolantTemp = result[6] / 10.0 -- Coolant temperature in °C\n-- Emit process parameters\nemit('./ProcessParameters/feedRate', feedRate)\nemit('./ProcessParameters/spindleSpeed', spindleSpeed)\nemit('./ProcessParameters/cutDepth', cutDepth)\nemit('./ProcessParameters/toolLife', toolLife)\nemit('./ProcessParameters/cycleTime', cycleTime)\nemit('./ProcessParameters/coolantTemp', coolantTemp)\nreturn 'Feed: ' .. feedRate .. ' IPM, Speed: ' .. spindleSpeed .. ' RPM'"
            },
            {
              "name": "MaintenanceCounters",
              "enabled": true,
              "type": 3,
              "address": 800,
              "count": 4,
              "rbe": true,
              "every": 10,
              "script": "-- Process maintenance counters\nif not result or #result < 4 then return nil end\n-- Extract maintenance data (32-bit values using pairs of registers)\nlocal operatingHours = struct.unpack('<I', struct.pack('<HH', result[1], result[2]))\nlocal cycleCount = struct.unpack('<I', struct.pack('<HH', result[3], result[4]))\n-- Emit maintenance counters\nemit('./MaintenanceCounters/operatingHours', operatingHours)\nemit('./MaintenanceCounters/cycleCount', cycleCount)\n-- Calculate hours since last maintenance (assuming 500 hour intervals)\nlocal hoursSinceMaint = operatingHours % 500\nlocal hoursUntilMaint = 500 - hoursSinceMaint\nemit('./MaintenanceCounters/hoursUntilMaintenance', hoursUntilMaint)\nreturn 'Hours: ' .. operatingHours .. ', Next maintenance in: ' .. hoursUntilMaint .. 'h'"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "mqttSource": {
      "description": "Subscribes to MQTT broker topics",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Broker hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Broker port",
          "default": 1883
        },
        "qos": {
          "type": "integer",
          "description": "Quality of Service (0, 1, 2)",
          "default": 0,
          "enum": [0, 1, 2]
        },
        "itemized_read": {
          "type": "boolean",
          "description": "When TRUE, streaming data from broker is matched against the 'items' list and processed, unmatched 'item.address' are dropped",
          "default": false
        },
        "clean_session": {
          "type": "boolean",
          "description": "MQTT clean session",
          "default": true
        },
        "tls": {
          "type": "boolean",
          "description": "SSL/TLS connection",
          "default": false
        },
        "tls_insecure": {
          "type": "boolean",
          "description": "Allow untrusted certificates",
          "default": false
        },
        "client_cert_path": {
          "type": "string",
          "description": "Relative or absolute path to the client certificate (.pfx)"
        },
        "client_cert_password": {
          "type": "string",
          "description": "Client certificate password"
        },
        "ca_cert_path": {
          "type": "string",
          "description": "Relative or absolute path to the certificate authority certificate"
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "mqttBroker1",
          "enabled": true,
          "connector": "mqtt",
          "scan_interval": 500,
          "rbe": true,
          "itemized_read": true,
          "lang_script": "Lua",
          "address": "mqtt.factory.example.com",
          "port": 8883,
          "qos": 1,
          "clean_session": true,
          "tls": true,
          "tls_insecure": false,
          "client_cert_path": "./certs/client.pfx",
          "client_cert_password": "certpass123",
          "ca_cert_path": "./certs/ca.crt",
          "username": "factory_user",
          "password": "secure_mqtt_password",
          "init_script": "-- Initialize MQTT data processing\nprint('MQTT connector initialized')\n-- Import JSON library for message parsing\njson = require('json')\nstringx = require('pl.stringx')\nmoses = require('moses')\n-- Initialize data validation functions\nfunction validateTemperature(temp)\n  return temp and temp >= -50 and temp <= 200\nend\nfunction validateHumidity(hum)\n  return hum and hum >= 0 and hum <= 100\nend\nfunction validatePressure(pressure)\n  return pressure and pressure >= 0 and pressure <= 1000\nend\n-- Initialize moving average arrays\ntemperatureBuffer = {}\npressureBuffer = {}",
          "enter_script": "-- Log MQTT message processing cycle\n-- print('MQTT message processing cycle started')",
          "exit_script": "-- Calculate facility-wide metrics\nlocal activeDevices = 0\nlocal totalEnergy = 0\nfor i = 1, 10 do\n  if cache('./Device' .. i .. '/status', 'offline') == 'online' then\n    activeDevices = activeDevices + 1\n  end\n  local energy = cache('./Device' .. i .. '/energy', 0)\n  totalEnergy = totalEnergy + energy\nend\nemit('./FacilityMetrics/activeDevices', activeDevices)\nemit('./FacilityMetrics/totalEnergyConsumption', totalEnergy)",
          "item_script": "-- Default processing for items without their own script\nlocal topic = this.Key or 'unknown'\nlocal payload = result or ''\n-- Extract device ID from topic if following standard pattern\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nif not deviceId then return payload end\n-- Try to parse as JSON, fallback to raw value\nlocal success, data = pcall(json.decode, payload)\nif success and data then\n  -- For JSON payloads, try to extract a meaningful value\n  local value = data.value or data.data or data.measurement\n  if value ~= nil then\n    emit('./Device' .. deviceId .. '/lastUpdate', os.time())\n    return value\n  else\n    return payload\n  end\nelse\n  -- For non-JSON payloads, return as-is\n  emit('./Device' .. deviceId .. '/lastUpdate', os.time())\n  return payload\nend",
          "items": [
            {
              "name": "SimpleHeartbeats",
              "enabled": true,
              "address": "factory/+/heartbeat",
              "rbe": false,
              "every": 1
            },
            {
              "name": "RawSensorReadings",
              "enabled": true,
              "address": "factory/+/sensors/raw",
              "rbe": true,
              "every": 1
            },
            {
              "name": "GenericStatus",
              "enabled": true,
              "address": "factory/+/status",
              "rbe": true,
              "every": 2
            },
            {
              "name": "TemperatureSensors",
              "enabled": true,
              "address": "factory/+/sensors/temperature",
              "rbe": true,
              "every": 1,
              "script": "-- Custom processing for temperature data (overrides item_script)\nlocal topic = this.Key or 'unknown'\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nif not deviceId then return nil end\n-- Parse temperature data\nlocal success, data = pcall(json.decode, result)\nif not success or not data then return nil end\nlocal temperature = tonumber(data.value or data.temperature)\nlocal unit = data.unit or 'C'\nlocal sensorId = data.sensorId or 'temp1'\n-- Validate temperature\nif not validateTemperature(temperature) then\n  emit('./Device' .. deviceId .. '/temperature/error', 'Invalid temperature')\n  return nil\nend\n-- Store in moving average buffer\ntable.insert(temperatureBuffer, temperature)\ntemperatureBuffer = moses.last(temperatureBuffer, 10)\nlocal avgTemp = moses.mean(temperatureBuffer)\n-- Emit temperature data\nemit('./Device' .. deviceId .. '/temperature', temperature)\nemit('./Device' .. deviceId .. '/temperature/unit', unit)\nemit('./Device' .. deviceId .. '/temperature/average', math.floor(avgTemp * 10) / 10)\nreturn deviceId .. ': ' .. temperature .. '°' .. unit",
              "sink": {
                "mtconnect": "Device[name=factory1]/Controller/Temperature[category=Sample]"
              }
            },
            {
              "name": "ProductionData",
              "enabled": true,
              "address": "factory/+/production/count",
              "rbe": true,
              "every": 1,
              "script": "-- Custom processing for production data (overrides item_script)\nlocal topic = this.Key or 'unknown'\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nif not deviceId then return nil end\n-- Parse production data\nlocal success, data = pcall(json.decode, result)\nif not success or not data then return nil end\nlocal partCount = tonumber(data.partCount or data.count)\nlocal goodParts = tonumber(data.goodParts)\nlocal rejectParts = tonumber(data.rejectParts)\nlocal operator = data.operator or 'Unknown'\n-- Validate part count\nif not partCount or partCount < 0 then return nil end\n-- Emit production metrics\nemit('./Device' .. deviceId .. '/production/partCount', partCount)\nif goodParts then\n  emit('./Device' .. deviceId .. '/production/goodParts', goodParts)\nend\nif rejectParts then\n  emit('./Device' .. deviceId .. '/production/rejectParts', rejectParts)\n  local qualityRate = goodParts and goodParts > 0 and (goodParts / (goodParts + rejectParts) * 100) or 100\n  emit('./Device' .. deviceId .. '/production/qualityRate', math.floor(qualityRate * 10) / 10)\nend\nemit('./Device' .. deviceId .. '/production/operator', operator)\nreturn deviceId .. ': ' .. partCount .. ' parts'",
              "sink": {
                "mtconnect": "Device[name=factory1]/Controller/PartCount[category=Event]"
              }
            },
            {
              "name": "AlarmNotifications",
              "enabled": true,
              "address": "factory/+/alarms/#",
              "rbe": false,
              "every": 1,
              "script": "-- Custom alarm processing (overrides item_script)\nlocal topic = this.Key or 'unknown'\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nlocal alarmType = string.match(topic, 'alarms/([^/]+)')\nif not deviceId or not alarmType then return nil end\n-- Parse alarm data\nlocal success, data = pcall(json.decode, result)\nif not success or not data then\n  -- Simple alarm message\n  emit('./Device' .. deviceId .. '/alarms/' .. alarmType, result)\n  return deviceId .. ': ' .. alarmType .. ' - ' .. result\nend\n-- Structured alarm data\nlocal severity = data.severity or 'INFO'\nlocal message = data.message or 'No message'\nlocal timestamp = data.timestamp or os.time()\n-- Emit alarm details\nemit('./Device' .. deviceId .. '/alarms/' .. alarmType .. '/severity', severity)\nemit('./Device' .. deviceId .. '/alarms/' .. alarmType .. '/message', message)\nemit('./Device' .. deviceId .. '/alarms/' .. alarmType .. '/timestamp', timestamp)\nreturn '[' .. severity .. '] ' .. deviceId .. '/' .. alarmType .. ': ' .. message"
            },
            {
              "name": "EnergyData",
              "enabled": true,
              "address": "factory/+/energy/consumption",
              "rbe": true,
              "every": 2,
              "script": "-- Custom energy processing (overrides item_script)\nlocal topic = this.Key or 'unknown'\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nif not deviceId then return nil end\n-- Parse energy data\nlocal success, data = pcall(json.decode, result)\nif not success or not data then return nil end\nlocal powerKW = tonumber(data.powerKW or data.power)\nlocal energyKWh = tonumber(data.energyKWh or data.energy)\nlocal voltage = tonumber(data.voltage)\n-- Validate and emit energy data\nif powerKW and powerKW >= 0 and powerKW <= 1000 then\n  emit('./Device' .. deviceId .. '/energy/power', powerKW)\nend\nif energyKWh and energyKWh >= 0 then\n  emit('./Device' .. deviceId .. '/energy/consumption', energyKWh)\nend\nif voltage and voltage >= 0 and voltage <= 600 then\n  emit('./Device' .. deviceId .. '/energy/voltage', voltage)\nend\nreturn deviceId .. ': ' .. (powerKW or 'N/A') .. ' kW'"
            },
            {
              "name": "MaintenanceMessages",
              "enabled": true,
              "address": "factory/+/maintenance/alert",
              "rbe": true,
              "every": 5
            },
            {
              "name": "DeviceEvents",
              "enabled": true,
              "address": "factory/+/events/+",
              "rbe": false,
              "every": 1
            },
            {
              "name": "QualityInspection",
              "enabled": true,
              "address": "factory/+/quality/inspection",
              "rbe": true,
              "every": 1,
              "script": "-- Custom quality processing (overrides item_script)\nlocal topic = this.Key or 'unknown'\nlocal deviceId = string.match(topic, 'factory/([^/]+)/')\nif not deviceId then return nil end\n-- Parse quality data\nlocal success, data = pcall(json.decode, result)\nif not success or not data then return nil end\nlocal inspectionId = data.inspectionId or 'unknown'\nlocal result_status = data.result or data.status or 'Unknown'\nlocal defectCount = tonumber(data.defectCount) or 0\nlocal inspector = data.inspector or 'Auto'\nlocal partNumber = data.partNumber or 'Unknown'\n-- Emit quality data\nemit('./Device' .. deviceId .. '/quality/inspectionId', inspectionId)\nemit('./Device' .. deviceId .. '/quality/result', result_status)\nemit('./Device' .. deviceId .. '/quality/defectCount', defectCount)\nemit('./Device' .. deviceId .. '/quality/inspector', inspector)\nemit('./Device' .. deviceId .. '/quality/partNumber', partNumber)\nlocal passed = result_status == 'PASS' or defectCount == 0\nreturn deviceId .. '/' .. inspectionId .. ': ' .. (passed and 'PASS' or 'FAIL')"
            },
            {
              "name": "SimpleNotifications",
              "enabled": true,
              "address": "factory/notifications/+",
              "rbe": false,
              "every": 1
            }
          ],
          "strip_path_prefix": false,
          "create_dummy_messages_on_startup": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "msSqlSource": {
      "description": "Reads data from a Microsoft SQL database",
      "type": "object",
      "properties": {
        "connection_string": {
          "type": "string",
          "description": "Database connection string"
        },
        "command_text": {
          "type": "string",
          "description": "SQL query"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["connection_string", "command_text"],
      "examples": [
        {
          "name": "mssql_source",
          "enabled": true,
          "scan_interval": 5000,
          "connector": "msSql",
          "rbe": true,
          "connection_string": "Server=172.16.10.5;Database=Manufacturing;User Id=datareader;Password=datareader;Encrypt=True;TrustServerCertificate=True;",
          "command_text": "SELECT TOP 10 OrderID, ProductName, Quantity, Status, CreatedDate, LastModified FROM dbo.ProductionOrders WHERE Status IN ('Active', 'Pending') ORDER BY LastModified DESC;",
          "init_script": "print('MSSQL connector initialized for database: Manufacturing');",
          "items": [
            {
              "name": "OrderNumber",
              "enabled": true,
              "address": "OrderID",
              "rbe": true,
              "script": "-- Get the most recent order ID\nif result and #result > 0 then\n  return result[1];  -- First row, OrderID column\nend\nreturn nil;"
            },
            {
              "name": "ProductName",
              "enabled": true,
              "address": "ProductName",
              "script": "-- Get the most recent product name\nif result and #result > 0 then\n  return result[1];\nend\nreturn nil;"
            },
            {
              "name": "TotalQuantity",
              "enabled": true,
              "address": "Quantity",
              "script": "-- Calculate total quantity from all rows\nlocal total = 0;\nif result then\n  for i = 1, #result do\n    if result[i] then\n      total = total + (tonumber(result[i]) or 0);\n    end\n  end\nend\nreturn total;"
            },
            {
              "name": "ActiveOrderCount",
              "enabled": true,
              "address": "Status",
              "script": "-- Count active orders\nlocal active_count = 0;\nif result then\n  for i = 1, #result do\n    if result[i] == 'Active' then\n      active_count = active_count + 1;\n    end\n  end\nend\nreturn active_count;"
            },
            {
              "name": "PendingOrderCount",
              "enabled": true,
              "address": "Status",
              "script": "-- Count pending orders\nlocal pending_count = 0;\nif result then\n  for i = 1, #result do\n    if result[i] == 'Pending' then\n      pending_count = pending_count + 1;\n    end\n  end\nend\nreturn pending_count;"
            },
            {
              "name": "LatestOrderDate",
              "enabled": true,
              "address": "LastModified",
              "script": "-- Get the most recent modification date\nif result and #result > 0 then\n  return result[1];  -- First row has most recent date due to ORDER BY\nend\nreturn nil;"
            },
            {
              "name": "OrderSummary",
              "enabled": true,
              "address": "OrderID",
              "rbe": false,
              "script": "-- Create comprehensive order summary\nlocal summary = {};\nif result then\n  for i = 1, #result do\n    if result[i] then\n      emit('./Order_' .. result[i] .. '_Status', cache('Status', {})[i] or 'Unknown');\n      emit('./Order_' .. result[i] .. '_Quantity', cache('Quantity', {})[i] or 0);\n    end\n  end\n  summary.total_orders = #result;\n  summary.timestamp = os.date('%Y-%m-%d %H:%M:%S');\nend\nreturn summary;"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        },
        {
          "name": "simple_mssql",
          "enabled": true,
          "connector": "msSql",
          "connection_string": "Server=localhost;Database=TestDB;Trusted_Connection=true;",
          "command_text": "SELECT ProductID, ProductName, Price FROM Products WHERE Active = 1;",
          "items": [
            {
              "name": "FirstProductID",
              "address": "ProductID",
              "script": "return result[1];"
            },
            {
              "name": "FirstProductName",
              "address": "ProductName",
              "script": "return result[1];"
            },
            {
              "name": "AveragePrice",
              "address": "Price",
              "script": "local sum = 0;\nlocal count = 0;\nfor i = 1, #result do\n  sum = sum + (tonumber(result[i]) or 0);\n  count = count + 1;\nend\nreturn count > 0 and (sum / count) or 0;"
            }
          ]
        }
      ]
    },
    "mtConnectAgentSource": {
      "description": "Reads streaming data from an external MTConnect Agent",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Agent hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Agent port",
          "default": 5000
        },
        "device": {
          "type": "string",
          "description": "Device name to query"
        },
        "itemized_read": {
          "type": "boolean",
          "description": "Process streaming data based on items array",
          "default": false
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "mtconnect_source",
          "enabled": true,
          "scan_interval": 1000,
          "connector": "mtConnectAgent",
          "rbe": true,
          "address": "mtconnect.mazakcorp.com",
          "port": 5719,
          "device": "HCN001",
          "init_script": "print('MTConnect Agent source initialized for device: ' .. configuration().Device);",
          "items": [
            {
              "name": "PathPositionSample",
              "enabled": true,
              "address": "pathpos",
              "rbe": true,
              "script": "-- Extract value from MTConnect data item\nif result and #result > 0 then\n  return result[1].Value;\nend\nreturn nil;"
            },
            {
              "name": "SpindleSpeed",
              "enabled": true,
              "address": "spindle_speed",
              "script": "-- Process spindle speed data\nif result and #result > 0 then\n  local speed = tonumber(result[1].Value);\n  if speed then\n    -- Emit additional derived values\n    emit('./SpindleSpeedRPM', speed);\n    if speed > 1000 then\n      emit('./SpindleStatus', 'HIGH_SPEED');\n    elseif speed > 0 then\n      emit('./SpindleStatus', 'NORMAL');\n    else\n      emit('./SpindleStatus', 'STOPPED');\n    end\n    return speed;\n  end\nend\nreturn 0;"
            },
            {
              "name": "MachineExecution",
              "enabled": true,
              "address": "execution",
              "script": "-- Map execution states\nif result and #result > 0 then\n  local state = result[1].Value;\n  local execution_map = {\n    ['ACTIVE'] = 'Running',\n    ['READY'] = 'Ready',\n    ['INTERRUPTED'] = 'Stopped',\n    ['STOPPED'] = 'Idle'\n  };\n  return execution_map[state] or state;\nend\nreturn 'Unknown';"
            },
            {
              "name": "ProgramName",
              "enabled": true,
              "address": "program",
              "rbe": true,
              "every": 5,
              "script": "-- Program name changes less frequently\nif result and #result > 0 then\n  return result[1].Value;\nend\nreturn nil;"
            },
            {
              "name": "ToolNumber",
              "enabled": true,
              "address": "tool_number",
              "script": "if result and #result > 0 then\n  local tool = result[1].Value;\n  if tool then\n    emit('./CurrentTool', tool);\n    -- Emit tool change event if different from previous\n    local previous_tool = cache('./PreviousTool', nil);\n    if previous_tool and previous_tool ~= tool then\n      emit('./ToolChanged', true);\n    else\n      emit('./ToolChanged', false);\n    end\n    set('PreviousTool', tool);\n    return tool;\n  end\nend\nreturn nil;"
            },
            {
              "name": "MachineAvailability",
              "enabled": true,
              "address": "avail",
              "script": "-- Process availability data\nif result and #result > 0 then\n  local avail = result[1].Value;\n  local availability_map = {\n    ['AVAILABLE'] = true,\n    ['UNAVAILABLE'] = false\n  };\n  local is_available = availability_map[avail];\n  if is_available ~= nil then\n    emit('./IsAvailable', is_available);\n    emit('./AvailabilityText', avail);\n    return is_available;\n  end\nend\nreturn false;"
            },
            {
              "name": "AxisPositions",
              "enabled": true,
              "address": "x_axis",
              "script": "-- Collect multiple axis positions\nlocal x_pos = nil;\nlocal y_pos = nil;\nlocal z_pos = nil;\n\nif result and #result > 0 then\n  x_pos = tonumber(result[1].Value);\nend\n\n-- Get Y and Z axis positions from cache\ny_pos = tonumber(cache('mtconnect_source/y_axis', 0));\nz_pos = tonumber(cache('mtconnect_source/z_axis', 0));\n\nif x_pos then\n  local position_data = {\n    x = x_pos,\n    y = y_pos,\n    z = z_pos,\n    timestamp = os.time()\n  };\n  \n  emit('./MachinePosition', position_data);\n  return x_pos;\nend\nreturn nil;"
            },
            {
              "name": "YAxisPosition",
              "enabled": true,
              "address": "y_axis",
              "script": "if result and #result > 0 then\n  return tonumber(result[1].Value);\nend\nreturn 0;"
            },
            {
              "name": "ZAxisPosition",
              "enabled": true,
              "address": "z_axis",
              "script": "if result and #result > 0 then\n  return tonumber(result[1].Value);\nend\nreturn 0;"
            },
            {
              "name": "AlarmStatus",
              "enabled": true,
              "address": "alarm",
              "rbe": true,
              "script": "-- Process alarm information\nif result and #result > 0 then\n  local alarm_data = result[1];\n  if alarm_data.Value and alarm_data.Value ~= '' then\n    emit('./AlarmActive', true);\n    emit('./AlarmCode', alarm_data.Value);\n    emit('./AlarmText', alarm_data.Value);\n    return {\n      active = true,\n      code = alarm_data.Value,\n      timestamp = alarm_data.Timestamp or os.time()\n    };\n  else\n    emit('./AlarmActive', false);\n    return { active = false };\n  end\nend\nreturn { active = false };"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "nwsWeatherSource": {
      "description": "Reads weather at the specified location",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server hostname or IP address",
          "default": "https://api.weather.gov"
        },
        "agent": {
          "type": "string",
          "description": "Unique user-agent",
          "default": "(MyWeatherApp, contact@example.com)"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/nwsWeatherItem" }
        }
      },
      "examples": [
        {
          "name": "nws_weather_source",
          "enabled": true,
          "scan_interval": 300000,
          "connector": "nwsWeather",
          "rbe": true,
          "address": "https://api.weather.gov",
          "agent": "(DimeWeatherApp, contact@mycompany.com)",
          "init_script": "json = require('json');\nprint('NWS Weather connector initialized');",
          "items": [
            {
              "name": "NewYorkWeather",
              "enabled": true,
              "address": "40.7128, -74.0060",
              "forecast": "daily",
              "rbe": true,
              "every": 1,
              "script": "-- Process New York daily weather\nif result and result.properties and result.properties.periods then\n  local current_period = result.properties.periods[1];\n  if current_period then\n    local temp = current_period.temperature;\n    local conditions = current_period.shortForecast;\n    local wind_speed = current_period.windSpeed;\n    \n    -- Emit individual weather components\n    emit('./NYC_Temperature', temp);\n    emit('./NYC_Conditions', conditions);\n    emit('./NYC_WindSpeed', wind_speed);\n    emit('./NYC_Humidity', current_period.relativeHumidity and current_period.relativeHumidity.value or nil);\n    \n    -- Create weather summary\n    local weather_summary = {\n      location = 'New York City',\n      temperature = temp,\n      conditions = conditions,\n      wind_speed = wind_speed,\n      forecast_time = current_period.startTime\n    };\n    \n    return weather_summary;\n  end\nend\nreturn nil;"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "opcDaSource": {
      "description": "Reads items from an OPC-DA server",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server node",
          "default": "Kepware.KEPServerEX.V6"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "examples": [
        {
          "name": "opcda_source",
          "enabled": true,
          "scan_interval": 1000,
          "connector": "opcDa",
          "rbe": true,
          "address": "Kepware.KEPServerEX.V6",
          "init_script": "print('OPC-DA connector initialized for server: ' .. configuration().Address);\nprint('Note: Requires 32-bit DIME build');",
          "items": [
            {
              "name": "SystemDateTime",
              "enabled": true,
              "address": "_System._DateTime",
              "rbe": false,
              "script": "-- System timestamp from OPC server\nif result then\n  emit('./ServerTime', result);\n  return result;\nend\nreturn nil;"
            },
            {
              "name": "PlcHeartbeat",
              "enabled": true,
              "address": "Channel1.Device1.Heartbeat",
              "script": "-- PLC heartbeat counter\nlocal heartbeat = tonumber(result);\nif heartbeat then\n  local prev_heartbeat = cache('PreviousHeartbeat', 0);\n  if heartbeat ~= prev_heartbeat then\n    emit('./PlcAlive', true);\n    emit('./HeartbeatCounter', heartbeat);\n  else\n    emit('./PlcAlive', false);\n  end\n  set('PreviousHeartbeat', heartbeat);\n  return heartbeat;\nend\nreturn 0;"
            },
            {
              "name": "ProductionCount",
              "enabled": true,
              "address": "Channel1.Device1.Production.GoodParts",
              "script": "-- Production counter with shift calculation\nlocal count = tonumber(result) or 0;\nlocal shift_start = cache('ShiftStartCount', count);\nlocal shift_parts = count - shift_start;\n\nemit('./TotalParts', count);\nemit('./ShiftParts', shift_parts);\n\n-- Calculate production rate (parts per minute)\nlocal current_time = os.time();\nlocal last_time = cache('LastCountTime', current_time);\nlocal last_count = cache('LastCount', count);\nlocal time_diff = current_time - last_time;\n\nif time_diff >= 60 then  -- Calculate rate every minute\n  local parts_diff = count - last_count;\n  local rate = parts_diff / (time_diff / 60);  -- parts per minute\n  emit('./ProductionRate', rate);\n  set('LastCountTime', current_time);\n  set('LastCount', count);\nend\n\nreturn count;"
            },
            {
              "name": "MachineStatus",
              "enabled": true,
              "address": "Channel1.Device1.Status.Running",
              "script": "-- Machine running status\nlocal is_running = result;\nif is_running then\n  emit('./MachineState', 'RUNNING');\n  emit('./IsProducing', true);\nelse\n  emit('./MachineState', 'STOPPED');\n  emit('./IsProducing', false);\nend\nreturn is_running;"
            },
            {
              "name": "Temperature",
              "enabled": true,
              "address": "Channel1.Device1.Sensors.Temperature",
              "script": "-- Temperature monitoring with alerts\nlocal temp = tonumber(result);\nif temp then\n  emit('./CurrentTemp', temp);\n  \n  -- Temperature alerts\n  if temp > 80 then\n    emit('./TempAlert', 'CRITICAL');\n    emit('./TempStatus', 'OVERHEATED');\n  elseif temp > 70 then\n    emit('./TempAlert', 'WARNING');\n    emit('./TempStatus', 'HIGH');\n  else\n    emit('./TempAlert', 'NORMAL');\n    emit('./TempStatus', 'NORMAL');\n  end\n  \n  return temp;\nend\nreturn 0;"
            },
            {
              "name": "AlarmStatus",
              "enabled": true,
              "address": "Channel1.Device1.Alarms.Active",
              "script": "-- Active alarm monitoring\nlocal alarm_active = result;\nif alarm_active then\n  emit('./AlarmActive', true);\n  emit('./MachineHealth', 'FAULT');\nelse\n  emit('./AlarmActive', false);\n  emit('./MachineHealth', 'NORMAL');\nend\nreturn alarm_active;"
            },
            {
              "name": "MotorSpeed",
              "enabled": true,
              "address": "Channel1.Device1.Motor.Speed",
              "script": "-- Motor speed with efficiency calculation\nlocal speed = tonumber(result) or 0;\nlocal target_speed = 1800;  -- RPM\nlocal efficiency = 0;\n\nif target_speed > 0 then\n  efficiency = (speed / target_speed) * 100;\nend\n\nemit('./MotorRPM', speed);\nemit('./MotorEfficiency', efficiency);\n\n-- Speed status\nif speed > target_speed * 1.1 then\n  emit('./SpeedStatus', 'OVERSPEED');\nelseif speed < target_speed * 0.9 then\n  emit('./SpeedStatus', 'UNDERSPEED');\nelse\n  emit('./SpeedStatus', 'NORMAL');\nend\n\nreturn speed;"
            },
            {
              "name": "QualityData",
              "enabled": true,
              "address": "Channel1.Device1.Quality.DefectCount",
              "every": 5,
              "script": "-- Quality monitoring (check every 5 cycles)\nlocal defects = tonumber(result) or 0;\nlocal total_parts = tonumber(cache('opcda_source/ProductionCount', 0));\nlocal defect_rate = 0;\n\nif total_parts > 0 then\n  defect_rate = (defects / total_parts) * 100;\nend\n\nemit('./DefectCount', defects);\nemit('./DefectRate', defect_rate);\n\n-- Quality alerts\nif defect_rate > 5 then\n  emit('./QualityAlert', 'HIGH_DEFECT_RATE');\nelseif defect_rate > 2 then\n  emit('./QualityAlert', 'WARNING');\nelse\n  emit('./QualityAlert', 'NORMAL');\nend\n\nreturn {\n  defects = defects,\n  rate = defect_rate,\n  total_parts = total_parts\n};"
            },
            {
              "name": "PlcVariables",
              "enabled": true,
              "address": "Channel1.Device1.Recipe.ActiveRecipe",
              "every": 10,
              "script": "-- Recipe and setup information (check every 10 cycles)\nlocal recipe = result;\nif recipe then\n  emit('./ActiveRecipe', recipe);\n  emit('./RecipeChanged', recipe ~= cache('PreviousRecipe', ''));\n  set('PreviousRecipe', recipe);\n  return recipe;\nend\nreturn 'No Recipe';"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "opcUaSource": {
      "description": "Reads items from an OPC-UA server",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Server port",
          "default": 49320
        },
        "path": {
          "type": "string",
          "description": "Server path"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout in milliseconds",
          "default": 1000
        },
        "mode": {
          "type": "integer",
          "description": "1=None, 2=Sign, 3=SignAndEncrypt",
          "default": 1,
          "enum": [1, 2, 3]
        },
        "policy": {
          "type": "integer",
          "description": "1=None, 2=Basic256, 3=Basic128Rsa15, 4=Basic256Sha256",
          "default": 1,
          "enum": [1, 2, 3, 4]
        },
        "anonymous": {
          "type": "boolean",
          "description": "Connect anonymously",
          "default": false
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        },
        "allow_status_codes": {
          "type": "array",
          "description": "List of allowed status codes",
          "items": {
            "type": "integer"
          }
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/opcUaItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "opcua_source",
          "enabled": true,
          "scan_interval": 1000,
          "connector": "opcUa",
          "rbe": true,
          "address": "localhost",
          "port": 49320,
          "path": "",
          "timeout": 2000,
          "mode": 1,
          "policy": 1,
          "anonymous": false,
          "username": "opcuser",
          "password": "opcpassword",
          "allow_status_codes": [2156724224, 2150694912],
          "init_script": "print('OPC-UA connector initialized for server: ' .. configuration().Address .. ':' .. configuration().Port);",
          "items": [
            {
              "name": "ServerDateTime",
              "enabled": true,
              "address": "_System._DateTime",
              "namespace": 2,
              "rbe": false,
              "script": "-- Server timestamp\nif result then\n  emit('./ServerTime', result);\n  return result;\nend\nreturn nil;"
            },
            {
              "name": "RandomValue",
              "enabled": true,
              "address": "Simulation Examples.Functions.Random6",
              "namespace": 2,
              "script": "-- Random simulation value\nlocal value = tonumber(result);\nif value then\n  -- Emit alerts based on value ranges\n  if value > 80 then\n    emit('./RandomAlert', 'HIGH');\n  elseif value < 20 then\n    emit('./RandomAlert', 'LOW');\n  else\n    emit('./RandomAlert', 'NORMAL');\n  end\n  return value;\nend\nreturn 0;"
            },
            {
              "name": "ProcessTemperature",
              "enabled": true,
              "address": "Process.Temperature",
              "namespace": 3,
              "script": "-- Process temperature monitoring\nlocal temp = tonumber(result);\nif temp then\n  emit('./TempCelsius', temp);\n  emit('./TempFahrenheit', (temp * 9/5) + 32);\n  \n  -- Temperature control logic\n  if temp > 100 then\n    emit('./TempAlert', 'CRITICAL_HIGH');\n    emit('./CoolingRequired', true);\n  elseif temp > 85 then\n    emit('./TempAlert', 'WARNING_HIGH');\n    emit('./CoolingRequired', false);\n  elseif temp < 10 then\n    emit('./TempAlert', 'CRITICAL_LOW');\n    emit('./HeatingRequired', true);\n  else\n    emit('./TempAlert', 'NORMAL');\n    emit('./CoolingRequired', false);\n    emit('./HeatingRequired', false);\n  end\n  \n  return temp;\nend\nreturn 0;"
            },
            {
              "name": "MotorStatus",
              "enabled": true,
              "address": "Motor.Running",
              "namespace": 3,
              "script": "-- Motor running status\nlocal running = result;\nif running then\n  emit('./MotorState', 'RUNNING');\n  emit('./IsOperational', true);\nelse\n  emit('./MotorState', 'STOPPED');\n  emit('./IsOperational', false);\nend\nreturn running;"
            },
            {
              "name": "ProductionCounter",
              "enabled": true,
              "address": "Production.GoodParts",
              "namespace": 3,
              "script": "-- Production counter with rate calculation\nlocal count = tonumber(result) or 0;\nlocal previous_count = cache('PreviousCount', count);\nlocal current_time = os.time();\nlocal last_time = cache('LastCountTime', current_time);\n\n-- Calculate production rate\nlocal time_diff = current_time - last_time;\nif time_diff >= 60 then  -- Every minute\n  local parts_produced = count - previous_count;\n  local rate = parts_produced / (time_diff / 60);  -- parts per minute\n  \n  emit('./ProductionRate', rate);\n  emit('./PartsThisMinute', parts_produced);\n  \n  set('PreviousCount', count);\n  set('LastCountTime', current_time);\nend\n\nemit('./TotalParts', count);\nreturn count;"
            },
            {
              "name": "QualityData",
              "enabled": true,
              "address": "Quality.DefectRate",
              "namespace": 3,
              "every": 3,
              "script": "-- Quality monitoring (every 3 cycles)\nlocal defect_rate = tonumber(result) or 0;\n\nemit('./DefectPercentage', defect_rate);\n\n-- Quality alerts\nif defect_rate > 5.0 then\n  emit('./QualityStatus', 'CRITICAL');\n  emit('./QualityAlert', 'HIGH_DEFECT_RATE');\nelseif defect_rate > 2.0 then\n  emit('./QualityStatus', 'WARNING');\n  emit('./QualityAlert', 'ELEVATED_DEFECTS');\nelse\n  emit('./QualityStatus', 'GOOD');\n  emit('./QualityAlert', 'NORMAL');\nend\n\nreturn defect_rate;"
            },
            {
              "name": "MachineAlarms",
              "enabled": true,
              "address": "Alarms.ActiveCount",
              "namespace": 3,
              "script": "-- Active alarm count\nlocal alarm_count = tonumber(result) or 0;\n\nemit('./ActiveAlarmCount', alarm_count);\n\nif alarm_count > 0 then\n  emit('./MachineHealth', 'FAULT');\n  emit('./AlarmsActive', true);\nelse\n  emit('./MachineHealth', 'NORMAL');\n  emit('./AlarmsActive', false);\nend\n\nreturn alarm_count;"
            },
            {
              "name": "EnergyConsumption",
              "enabled": true,
              "address": "Energy.CurrentPower",
              "namespace": 4,
              "script": "-- Energy monitoring\nlocal power_kw = tonumber(result) or 0;\n\nemit('./PowerKW', power_kw);\nemit('./PowerWatts', power_kw * 1000);\n\n-- Calculate energy consumption\nlocal current_time = os.time();\nlocal last_time = cache('LastEnergyTime', current_time);\nlocal time_diff_hours = (current_time - last_time) / 3600;\n\nif time_diff_hours >= 0.25 then  -- Every 15 minutes\n  local energy_consumed = power_kw * time_diff_hours;  -- kWh\n  local total_energy = cache('TotalEnergy', 0) + energy_consumed;\n  \n  emit('./EnergyThisPeriod', energy_consumed);\n  emit('./TotalEnergyKWh', total_energy);\n  \n  set('TotalEnergy', total_energy);\n  set('LastEnergyTime', current_time);\nend\n\n-- Power alerts\nif power_kw > 50 then\n  emit('./PowerAlert', 'HIGH_CONSUMPTION');\nelseif power_kw < 5 then\n  emit('./PowerAlert', 'LOW_CONSUMPTION');\nelse\n  emit('./PowerAlert', 'NORMAL');\nend\n\nreturn power_kw;"
            },
            {
              "name": "EquipmentStatus",
              "enabled": true,
              "address": "Equipment.OverallStatus",
              "namespace": 3,
              "every": 5,
              "script": "-- Overall equipment status (every 5 cycles)\nlocal status = result;\nlocal status_map = {\n  ['0'] = 'STOPPED',\n  ['1'] = 'STARTING',\n  ['2'] = 'RUNNING',\n  ['3'] = 'STOPPING',\n  ['4'] = 'FAULT',\n  ['5'] = 'MAINTENANCE'\n};\n\nlocal status_text = status_map[tostring(status)] or 'UNKNOWN';\nemit('./EquipmentState', status_text);\n\n-- Availability calculation\nlocal is_available = (status_text == 'RUNNING' or status_text == 'STARTING');\nemit('./IsAvailable', is_available);\n\nreturn {\n  code = status,\n  text = status_text,\n  available = is_available\n};"
            },
            {
              "name": "RecipeData",
              "enabled": true,
              "address": "Recipe.ActiveRecipe",
              "namespace": 3,
              "every": 10,
              "script": "-- Recipe information (every 10 cycles)\nlocal recipe = result;\nif recipe then\n  emit('./CurrentRecipe', recipe);\n  \n  -- Detect recipe changes\n  local previous_recipe = cache('PreviousRecipe', '');\n  if recipe ~= previous_recipe then\n    emit('./RecipeChanged', true);\n    emit('./RecipeChangeTime', os.date('%Y-%m-%d %H:%M:%S'));\n    set('PreviousRecipe', recipe);\n  else\n    emit('./RecipeChanged', false);\n  end\n  \n  return recipe;\nend\nreturn 'No Recipe';"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "postgresSource": {
      "description": "Reads data from a PostgreSQL database",
      "type": "object",
      "properties": {
        "connection_string": {
          "type": "string",
          "description": "Database connection string"
        },
        "command_text": {
          "type": "string",
          "description": "SQL query"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["connection_string", "command_text"],
      "examples": [
        {
          "name": "postgres_source",
          "enabled": true,
          "scan_interval": 5000,
          "connector": "postgres",
          "rbe": true,
          "connection_string": "Host=172.16.10.43;Port=5432;Username=postgres;Password=postgres;Database=manufacturing;",
          "command_text": "SELECT order_id, product_name, quantity, status, created_date, last_modified, operator_id FROM production_orders WHERE status IN ('Active', 'Processing') AND last_modified >= NOW() - INTERVAL '1 hour' ORDER BY last_modified DESC LIMIT 20;",
          "init_script": "print('PostgreSQL connector initialized for manufacturing database');",
          "items": [
            {
              "name": "LatestOrderID",
              "enabled": true,
              "address": "order_id",
              "rbe": true,
              "script": "-- Get the most recent order ID\nif result and #result > 0 then\n  return result[1];  -- First row, most recent\nend\nreturn nil;"
            },
            {
              "name": "ActiveOrderCount",
              "enabled": true,
              "address": "status",
              "script": "-- Count active orders\nlocal active_count = 0;\nlocal processing_count = 0;\n\nif result then\n  for i = 1, #result do\n    if result[i] == 'Active' then\n      active_count = active_count + 1;\n    elseif result[i] == 'Processing' then\n      processing_count = processing_count + 1;\n    end\n  end\nend\n\nemit('./ActiveOrders', active_count);\nemit('./ProcessingOrders', processing_count);\nemit('./TotalOrders', active_count + processing_count);\n\nreturn {\n  active = active_count,\n  processing = processing_count,\n  total = active_count + processing_count\n};"
            },
            {
              "name": "TotalQuantity",
              "enabled": true,
              "address": "quantity",
              "script": "-- Calculate total quantity across all orders\nlocal total = 0;\nlocal max_qty = 0;\nlocal min_qty = math.huge;\n\nif result then\n  for i = 1, #result do\n    local qty = tonumber(result[i]) or 0;\n    total = total + qty;\n    if qty > max_qty then max_qty = qty; end\n    if qty < min_qty then min_qty = qty; end\n  end\nend\n\nif min_qty == math.huge then min_qty = 0; end\n\nemit('./TotalQuantity', total);\nemit('./MaxOrderQuantity', max_qty);\nemit('./MinOrderQuantity', min_qty);\n\nif #result > 0 then\n  emit('./AvgOrderQuantity', total / #result);\nend\n\nreturn total;"
            },
            {
              "name": "ProductMix",
              "enabled": true,
              "address": "product_name",
              "script": "-- Analyze product mix\nlocal product_counts = {};\nlocal unique_products = 0;\n\nif result then\n  for i = 1, #result do\n    local product = result[i];\n    if product then\n      if product_counts[product] then\n        product_counts[product] = product_counts[product] + 1;\n      else\n        product_counts[product] = 1;\n        unique_products = unique_products + 1;\n      end\n    end\n  end\nend\n\nemit('./UniqueProducts', unique_products);\n\n-- Emit top products\nlocal top_product = nil;\nlocal top_count = 0;\nfor product, count in pairs(product_counts) do\n  emit('./Product_' .. product .. '_Count', count);\n  if count > top_count then\n    top_count = count;\n    top_product = product;\n  end\nend\n\nif top_product then\n  emit('./TopProduct', top_product);\n  emit('./TopProductCount', top_count);\nend\n\nreturn product_counts;"
            },
            {
              "name": "OperatorWorkload",
              "enabled": true,
              "address": "operator_id",
              "every": 2,
              "script": "-- Operator workload analysis (every 2 cycles)\nlocal operator_loads = {};\n\nif result then\n  for i = 1, #result do\n    local operator = result[i];\n    if operator then\n      operator_loads[operator] = (operator_loads[operator] or 0) + 1;\n    end\n  end\nend\n\n-- Emit workload per operator\nfor operator, load in pairs(operator_loads) do\n  emit('./Operator_' .. operator .. '_Orders', load);\nend\n\nreturn operator_loads;"
            },
            {
              "name": "OrderAging",
              "enabled": true,
              "address": "created_date",
              "script": "-- Calculate order aging\nlocal current_time = os.time();\nlocal aged_orders = 0;\nlocal urgent_orders = 0;\nlocal total_age_hours = 0;\n\nif result then\n  for i = 1, #result do\n    local created_date = result[i];\n    if created_date then\n      -- Parse PostgreSQL timestamp (simplified)\n      local year, month, day, hour, min, sec = created_date:match('(%d+)-(%d+)-(%d+) (%d+):(%d+):(%d+)');\n      if year then\n        local created_time = os.time({\n          year = tonumber(year),\n          month = tonumber(month),\n          day = tonumber(day),\n          hour = tonumber(hour),\n          min = tonumber(min),\n          sec = tonumber(sec)\n        });\n        \n        local age_seconds = current_time - created_time;\n        local age_hours = age_seconds / 3600;\n        total_age_hours = total_age_hours + age_hours;\n        \n        if age_hours > 24 then\n          aged_orders = aged_orders + 1;\n        end\n        if age_hours > 48 then\n          urgent_orders = urgent_orders + 1;\n        end\n      end\n    end\n  end\nend\n\nemit('./AgedOrders', aged_orders);\nemit('./UrgentOrders', urgent_orders);\n\nif #result > 0 then\n  emit('./AvgOrderAgeHours', total_age_hours / #result);\nend\n\nreturn {\n  aged = aged_orders,\n  urgent = urgent_orders,\n  avg_age_hours = #result > 0 and (total_age_hours / #result) or 0\n};"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "redisSource": {
      "description": "Reads data from Redis",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Server hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Server port",
          "default": 6379
        },
        "database": {
          "type": "integer",
          "description": "Database ID",
          "default": 0
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "redis_source",
          "enabled": true,
          "scan_interval": 2000,
          "connector": "redis",
          "rbe": true,
          "address": "172.24.56.104",
          "port": 6379,
          "database": 0,
          "init_script": "print('Redis source connector initialized for database: ' .. configuration().Database);",
          "items": [
            {
              "name": "PlcGoodPartCount",
              "enabled": true,
              "address": "eipSource1/GoodPartCount",
              "rbe": true,
              "script": "-- Read cached PLC part count\nlocal count = tonumber(result);\nif count then\n  -- Calculate shift production\n  local shift_start = cache('ShiftStartCount', count);\n  local shift_parts = count - shift_start;\n  \n  emit('./TotalParts', count);\n  emit('./ShiftParts', shift_parts);\n  \n  -- Production rate calculation\n  local current_time = os.time();\n  local last_time = cache('LastCountTime', current_time);\n  local last_count = cache('LastCount', count);\n  local time_diff = current_time - last_time;\n  \n  if time_diff >= 60 then  -- Every minute\n    local parts_diff = count - last_count;\n    local rate = parts_diff / (time_diff / 60);  -- parts per minute\n    emit('./ProductionRate', rate);\n    set('LastCountTime', current_time);\n    set('LastCount', count);\n  end\n  \n  return count;\nend\nreturn 0;"
            },
            {
              "name": "MachineStatus",
              "enabled": true,
              "address": "machine1/status",
              "script": "-- Machine status from Redis cache\nlocal status = result;\nif status then\n  local status_map = {\n    ['1'] = 'RUNNING',\n    ['0'] = 'STOPPED',\n    ['2'] = 'FAULT',\n    ['3'] = 'MAINTENANCE'\n  };\n  \n  local status_text = status_map[tostring(status)] or 'UNKNOWN';\n  emit('./MachineState', status_text);\n  emit('./IsRunning', status_text == 'RUNNING');\n  \n  return status_text;\nend\nreturn 'OFFLINE';"
            },
            {
              "name": "TemperatureReading",
              "enabled": true,
              "address": "sensors/temperature/zone1",
              "script": "-- Temperature sensor data\nlocal temp = tonumber(result);\nif temp then\n  emit('./Temperature', temp);\n  \n  -- Temperature alerts\n  if temp > 85 then\n    emit('./TempAlert', 'CRITICAL');\n    emit('./CoolingRequired', true);\n  elseif temp > 75 then\n    emit('./TempAlert', 'WARNING');\n    emit('./CoolingRequired', false);\n  else\n    emit('./TempAlert', 'NORMAL');\n    emit('./CoolingRequired', false);\n  end\n  \n  -- Store min/max for the day\n  local current_min = cache('DailyMinTemp', temp);\n  local current_max = cache('DailyMaxTemp', temp);\n  \n  if temp < current_min then\n    set('DailyMinTemp', temp);\n    emit('./DailyMinTemp', temp);\n  end\n  \n  if temp > current_max then\n    set('DailyMaxTemp', temp);\n    emit('./DailyMaxTemp', temp);\n  end\n  \n  return temp;\nend\nreturn nil;"
            },
            {
              "name": "SystemMetrics",
              "enabled": true,
              "address": "$SYSTEM/metrics",
              "every": 3,
              "script": "-- System metrics (every 3 cycles)\nif result then\n  -- Parse JSON metrics if stored as JSON string\n  local metrics = nil;\n  if type(result) == 'string' then\n    metrics = from_json(result);\n  else\n    metrics = result;\n  end\n  \n  if metrics then\n    emit('./CPUUsage', metrics.cpu or 0);\n    emit('./MemoryUsage', metrics.memory or 0);\n    emit('./DiskUsage', metrics.disk or 0);\n    \n    -- System health alerts\n    local health_status = 'GOOD';\n    if metrics.cpu > 90 or metrics.memory > 90 or metrics.disk > 90 then\n      health_status = 'CRITICAL';\n    elseif metrics.cpu > 75 or metrics.memory > 75 or metrics.disk > 75 then\n      health_status = 'WARNING';\n    end\n    \n    emit('./SystemHealth', health_status);\n    return metrics;\n  end\nend\nreturn nil;"
            },
            {
              "name": "UserSessions",
              "enabled": true,
              "address": "app/active_sessions",
              "every": 5,
              "script": "-- Active user sessions count (every 5 cycles)\nlocal sessions = tonumber(result) or 0;\nemit('./ActiveSessions', sessions);\n\n-- Session load alerts\nif sessions > 100 then\n  emit('./SessionAlert', 'HIGH_LOAD');\nelseif sessions > 50 then\n  emit('./SessionAlert', 'MODERATE_LOAD');\nelse\n  emit('./SessionAlert', 'NORMAL');\nend\n\nreturn sessions;"
            },
            {
              "name": "CacheHitRatio",
              "enabled": true,
              "address": "cache/hit_ratio",
              "every": 4,
              "script": "-- Cache performance monitoring\nlocal hit_ratio = tonumber(result);\nif hit_ratio then\n  emit('./CacheHitRatio', hit_ratio);\n  \n  -- Performance alerts\n  if hit_ratio < 0.7 then\n    emit('./CachePerformance', 'POOR');\n  elseif hit_ratio < 0.9 then\n    emit('./CachePerformance', 'FAIR');\n  else\n    emit('./CachePerformance', 'EXCELLENT');\n  end\n  \n  return hit_ratio * 100;  -- Return as percentage\nend\nreturn 0;"
            },
            {
              "name": "QueueLength",
              "enabled": true,
              "address": "queue/processing",
              "script": "-- Processing queue monitoring\nlocal queue_length = tonumber(result) or 0;\nemit('./QueueLength', queue_length);\n\n-- Queue alerts\nif queue_length > 1000 then\n  emit('./QueueAlert', 'CRITICAL');\n  emit('./QueueStatus', 'OVERLOADED');\nelseif queue_length > 500 then\n  emit('./QueueAlert', 'WARNING');\n  emit('./QueueStatus', 'HIGH');\nelse\n  emit('./QueueAlert', 'NORMAL');\n  emit('./QueueStatus', 'NORMAL');\nend\n\n-- Estimate processing time\nlocal processing_rate = cache('ProcessingRate', 10);  -- items per minute\nif queue_length > 0 and processing_rate > 0 then\n  local estimated_time = queue_length / processing_rate;\n  emit('./EstimatedProcessingTime', estimated_time);\nend\n\nreturn queue_length;"
            },
            {
              "name": "ErrorCount",
              "enabled": true,
              "address": "errors/count/last_hour",
              "script": "-- Error monitoring\nlocal errors = tonumber(result) or 0;\nemit('./ErrorCount', errors);\n\n-- Error rate alerts\nif errors > 100 then\n  emit('./ErrorLevel', 'CRITICAL');\n  emit('./SystemStability', 'UNSTABLE');\nelseif errors > 50 then\n  emit('./ErrorLevel', 'HIGH');\n  emit('./SystemStability', 'DEGRADED');\nelseif errors > 10 then\n  emit('./ErrorLevel', 'MODERATE');\n  emit('./SystemStability', 'STABLE');\nelse\n  emit('./ErrorLevel', 'LOW');\n  emit('./SystemStability', 'STABLE');\nend\n\nreturn errors;"
            },
            {
              "name": "ConfigurationData",
              "enabled": true,
              "address": "config/machine_settings",
              "every": 10,
              "rbe": true,
              "script": "-- Configuration monitoring (every 10 cycles)\nif result then\n  local config = nil;\n  \n  -- Handle JSON configuration\n  if type(result) == 'string' then\n    config = from_json(result);\n  else\n    config = result;\n  end\n  \n  if config then\n    -- Emit individual configuration values\n    for key, value in pairs(config) do\n      emit('./Config_' .. key, value);\n    end\n    \n    -- Check for configuration changes\n    local config_hash = tostring(config):len();  -- Simple hash\n    local previous_hash = cache('ConfigHash', config_hash);\n    \n    if config_hash ~= previous_hash then\n      emit('./ConfigurationChanged', true);\n      emit('./ConfigChangeTime', os.date('%Y-%m-%d %H:%M:%S'));\n      set('ConfigHash', config_hash);\n    else\n      emit('./ConfigurationChanged', false);\n    end\n    \n    return config;\n  end\nend\nreturn nil;"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "scriptSource": {
      "description": "Executes arbitrary scripts",
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "examples": [
        {
          "name": "script_source",
          "enabled": true,
          "scan_interval": 1000,
          "connector": "script",
          "rbe": true,
          "items": [
            {
              "name": "RandomNumber",
              "script": "return math.random(100);"
            },
            {
              "name": "CurrentTime",
              "script": "return os.date('%Y-%m-%d %H:%M:%S');"
            },
            {
              "name": "Counter",
              "script": "local count = cache('counter', 0) + 1;\nset('counter', count);\nreturn count;"
            },
            {
              "name": "Temperature",
              "script": "local base = 72;\nlocal variation = math.random(-5, 5);\nreturn base + variation;"
            }
          ]
        }
      ]
    },
    "siemensS7Source": {
      "description": "Reads registers from a Siemens S7 PLC",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "PLC type",
          "default": "S71200",
          "enum": ["S71200", "S7200", "S7300", "S7400", "S7200Smart", "S71500", "Logo0BA8"]
        },
        "address": {
          "type": "string",
          "description": "PLC hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "PLC port",
          "default": 102
        },
        "rack": {
          "type": "integer",
          "description": "PLC rack",
          "default": 0
        },
        "slot": {
          "type": "integer",
          "description": "PLC slot",
          "default": 0
        },
        "bypass_ping": {
          "type": "boolean",
          "description": "Ping PLC before reading to determine connector connection status",
          "default": false
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/siemensS7Item" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "siemens_s7_source",
          "enabled": true,
          "scan_interval": 1500,
          "connector": "siemensS7",
          "rbe": true,
          "type": "S71200",
          "address": "192.168.111.20",
          "port": 102,
          "rack": 0,
          "slot": 0,
          "bypass_ping": true,
          "init_script": "print('Siemens S7 PLC connector initialized for: ' .. configuration().Address);",
          "items": [
            {
              "name": "MachineRunning",
              "enabled": true,
              "address": "M0.0",
              "type": "bool",
              "script": "-- Machine running status\nlocal running = result;\nif running then\n  emit('./MachineState', 'RUNNING');\n  emit('./IsOperational', true);\nelse\n  emit('./MachineState', 'STOPPED');\n  emit('./IsOperational', false);\nend\nreturn running;"
            },
            {
              "name": "EmergencyStop",
              "enabled": true,
              "address": "I0.0",
              "type": "bool",
              "script": "-- Emergency stop input\nlocal estop = result;\nif estop then\n  emit('./SafetyStatus', 'E_STOP_ACTIVE');\n  emit('./SafetyAlert', 'CRITICAL');\nelse\n  emit('./SafetyStatus', 'NORMAL');\n  emit('./SafetyAlert', 'NONE');\nend\nreturn estop;"
            },
            {
              "name": "ProductionCounter",
              "enabled": true,
              "address": "DB1.DBD0",
              "type": "int",
              "script": "-- Production counter with rate calculation\nlocal count = tonumber(result) or 0;\nlocal previous_count = cache('PreviousCount', count);\nlocal current_time = os.time();\nlocal last_time = cache('LastCountTime', current_time);\n\n-- Calculate production rate\nlocal time_diff = current_time - last_time;\nif time_diff >= 60 then  -- Every minute\n  local parts_produced = count - previous_count;\n  local rate = parts_produced / (time_diff / 60);  -- parts per minute\n  \n  emit('./ProductionRate', rate);\n  emit('./PartsThisMinute', parts_produced);\n  \n  set('PreviousCount', count);\n  set('LastCountTime', current_time);\nend\n\nemit('./TotalParts', count);\n\n-- Shift production calculation\nlocal shift_start = cache('ShiftStartCount', count);\nemit('./ShiftParts', count - shift_start);\n\nreturn count;"
            },
            {
              "name": "MotorSpeed",
              "enabled": true,
              "address": "DB1.DBD10",
              "type": "int",
              "script": "-- Motor speed monitoring\nlocal speed = tonumber(result) or 0;\nlocal target_speed = 1800;  -- RPM\n\nemit('./MotorRPM', speed);\n\n-- Speed status and efficiency\nlocal efficiency = 0;\nif target_speed > 0 then\n  efficiency = (speed / target_speed) * 100;\nend\n\nemit('./MotorEfficiency', efficiency);\n\n-- Speed alerts\nif speed > target_speed * 1.1 then\n  emit('./SpeedAlert', 'OVERSPEED');\nelseif speed < target_speed * 0.8 then\n  emit('./SpeedAlert', 'UNDERSPEED');\nelse\n  emit('./SpeedAlert', 'NORMAL');\nend\n\nreturn speed;"
            },
            {
              "name": "ProcessTemperature",
              "enabled": true,
              "address": "DB2.DBD0",
              "type": "float",
              "script": "-- Process temperature monitoring\nlocal temp = tonumber(result) or 0;\n\nemit('./Temperature', temp);\nemit('./TempFahrenheit', (temp * 9/5) + 32);\n\n-- Temperature control and alerts\nif temp > 85 then\n  emit('./TempAlert', 'CRITICAL_HIGH');\n  emit('./CoolingRequired', true);\nelseif temp > 75 then\n  emit('./TempAlert', 'WARNING_HIGH');\n  emit('./CoolingRequired', false);\nelseif temp < 10 then\n  emit('./TempAlert', 'CRITICAL_LOW');\n  emit('./HeatingRequired', true);\nelse\n  emit('./TempAlert', 'NORMAL');\n  emit('./CoolingRequired', false);\n  emit('./HeatingRequired', false);\nend\n\n-- Track daily min/max\nlocal daily_min = cache('DailyMinTemp', temp);\nlocal daily_max = cache('DailyMaxTemp', temp);\n\nif temp < daily_min then\n  set('DailyMinTemp', temp);\n  emit('./DailyMinTemp', temp);\nend\n\nif temp > daily_max then\n  set('DailyMaxTemp', temp);\n  emit('./DailyMaxTemp', temp);\nend\n\nreturn temp;"
            },
            {
              "name": "ActiveRecipe",
              "enabled": true,
              "address": "DB3.DBB0",
              "type": "int",
              "every": 5,
              "script": "-- Active recipe number (check every 5 cycles)\nlocal recipe_num = tonumber(result) or 0;\nlocal recipe_map = {\n  [1] = 'Product_A',\n  [2] = 'Product_B',\n  [3] = 'Product_C',\n  [0] = 'No_Recipe'\n};\n\nlocal recipe_name = recipe_map[recipe_num] or 'Unknown';\nemit('./RecipeNumber', recipe_num);\nemit('./RecipeName', recipe_name);\n\n-- Detect recipe changes\nlocal previous_recipe = cache('PreviousRecipe', recipe_num);\nif recipe_num ~= previous_recipe then\n  emit('./RecipeChanged', true);\n  emit('./RecipeChangeTime', os.date('%Y-%m-%d %H:%M:%S'));\n  set('PreviousRecipe', recipe_num);\nelse\n  emit('./RecipeChanged', false);\nend\n\nreturn {\n  number = recipe_num,\n  name = recipe_name\n};"
            },
            {
              "name": "AlarmWord",
              "enabled": true,
              "address": "DB4.DBW0",
              "type": "int",
              "script": "-- Alarm word processing\nlocal alarm_word = tonumber(result) or 0;\nlocal active_alarms = {};\nlocal alarm_count = 0;\n\n-- Check individual alarm bits\nlocal alarm_names = {\n  [0] = 'Motor_Fault',\n  [1] = 'Overheating',\n  [2] = 'Low_Pressure',\n  [3] = 'Door_Open',\n  [4] = 'Emergency_Stop',\n  [5] = 'Material_Empty'\n};\n\nfor bit = 0, 15 do\n  local is_active = (alarm_word & (1 << bit)) ~= 0;\n  local alarm_name = alarm_names[bit] or ('Alarm_' .. bit);\n  \n  emit('./Alarm_' .. alarm_name, is_active);\n  \n  if is_active then\n    table.insert(active_alarms, alarm_name);\n    alarm_count = alarm_count + 1;\n  end\nend\n\nemit('./ActiveAlarmCount', alarm_count);\nemit('./AnyAlarmsActive', alarm_count > 0);\n\nif alarm_count > 0 then\n  emit('./MachineHealth', 'FAULT');\nelse\n  emit('./MachineHealth', 'NORMAL');\nend\n\nreturn {\n  word = alarm_word,\n  count = alarm_count,\n  alarms = active_alarms\n};"
            },
            {
              "name": "QualityData",
              "enabled": true,
              "address": "DB5.DBD0",
              "type": "int",
              "every": 3,
              "script": "-- Quality monitoring (every 3 cycles)\nlocal defect_count = tonumber(result) or 0;\nlocal total_parts = tonumber(cache('siemens_s7_source/ProductionCounter', 1));\nlocal defect_rate = 0;\n\nif total_parts > 0 then\n  defect_rate = (defect_count / total_parts) * 100;\nend\n\nemit('./DefectCount', defect_count);\nemit('./DefectRate', defect_rate);\n\n-- Quality status\nif defect_rate > 5 then\n  emit('./QualityStatus', 'POOR');\nelseif defect_rate > 2 then\n  emit('./QualityStatus', 'ACCEPTABLE');\nelse\n  emit('./QualityStatus', 'EXCELLENT');\nend\n\nreturn {\n  defects = defect_count,\n  rate = defect_rate,\n  total = total_parts\n};"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "address": "DB6.DBD0",
              "type": "int",
              "script": "-- Cycle time in milliseconds\nlocal cycle_ms = tonumber(result) or 0;\nlocal cycle_seconds = cycle_ms / 1000;\n\nemit('./CycleTimeMS', cycle_ms);\nemit('./CycleTimeSeconds', cycle_seconds);\n\n-- Cycle time analysis\nlocal target_cycle = 30;  -- seconds\nlocal efficiency = 0;\n\nif cycle_seconds > 0 then\n  efficiency = (target_cycle / cycle_seconds) * 100;\nend\n\nemit('./CycleEfficiency', efficiency);\n\n-- Performance alerts\nif cycle_seconds > target_cycle * 1.2 then\n  emit('./CycleAlert', 'SLOW');\nelseif cycle_seconds < target_cycle * 0.8 then\n  emit('./CycleAlert', 'FAST');\nelse\n  emit('./CycleAlert', 'NORMAL');\nend\n\nreturn cycle_seconds;"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "snmpSource": {
      "description": "Reads SNMP device",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Device hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Device port",
          "default": 161
        },
        "community": {
          "type": "string",
          "description": "Community",
          "default": "public"
        },
        "timeout": {
          "type": "integer",
          "description": "Read timeout",
          "default": 1000
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "snmp_source",
          "enabled": true,
          "scan_interval": 2000,
          "connector": "snmp",
          "rbe": true,
          "address": "192.168.150.143",
          "port": 161,
          "community": "public",
          "timeout": 1000,
          "init_script": "print('SNMP connector initialized for device: ' .. configuration().Address);",
          "items": [
            {
              "name": "Temperature",
              "enabled": true,
              "address": "1.3.6.1.4.1.6574.1.2.0",
              "rbe": true,
              "every": 1,
              "script": "-- Convert temperature if needed\nlocal temp_celsius = tonumber(result);\nif temp_celsius then\n  return temp_celsius / 1000;  -- Convert from millidegrees\nend\nreturn result;"
            }
          ],
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "sparkplugBSource": {
      "description": "Subscribes to a SparkplugB host",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Host hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Host port",
          "default": 1883
        },
        "username": {
          "type": "string",
          "description": "Username"
        },
        "password": {
          "type": "string",
          "description": "Password"
        },
        "clean_session": {
          "type": "boolean",
          "description": "Clean session",
          "default": true
        },
        "qos": {
          "type": "integer",
          "description": "Quality of service (0, 1, 2)",
          "default": 0,
          "enum": [0, 1, 2]
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "spb",
          "enabled": true,
          "scan_interval": 1000,
          "connector": "sparkplugB",
          "rbe": true,
          "itemized_read": false,
          "address": "localhost",
          "port": 1883,
          "username": "user",
          "password": "password",
          "clean_session": true,
          "qos": 0,
          "init_script": "import('System');\njson = require('json');\nget_metric_value = function(metric)\n  local dt = Convert.ToInt32(metric.Datatype);\n  local value = nil;\n  if dt == 12 then\n    value = metric.StringValue:ToString();\n  elseif dt == 11 then\n    value = Convert.ToBoolean(metric.BooleanValue);\n  elseif dt == 10 then\n    value = Convert.ToDouble(metric.DoubleValue);\n  elseif dt == 9 then\n    value = Convert.ToDouble(metric.FloatValue);\n  elseif dt == 8 or dt == 4 then\n    value = Convert.ToInt32(metric.LongValue);\n  elseif dt <= 7 then\n    value = Convert.ToInt32(metric.IntValue);\n  else\n    value = nil;\n  end\n  return value;\nend",
          "items": [
            {
              "name": "F1D1",
              "address": "spBv1.0/Chicago/DDATA/Factory1/DIME1",
              "script": "result = from_json(result);\nfor metric in luanet.each(result.Metrics) do;\n  local value = get_metric_value(metric);\n  emit(\".\/\" .. metric.Name:ToString(), value);\nend;\nreturn nil;"
            }
          ]
        }
      ]
    },
    "tcpAsciiSource": {
      "description": "Sends ASCII commands over a socket and reads back the response",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Port",
          "default": 23
        },
        "read_delay": {
          "type": "integer",
          "description": "Delay in milliseconds between socket write and socket read",
          "default": 0
        },
        "reuse_connection": {
          "type": "boolean",
          "description": "Maintain a single connection",
          "default": true
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "tcpAsciiDevice1",
          "enabled": true,
          "connector": "tcpAscii",
          "scan_interval": 2000,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.216",
          "port": 5051,
          "read_delay": 400,
          "reuse_connection": true,
          "init_script": "-- Initialize TCP ASCII communication\nprint('TCP ASCII connector initialized')\n-- Import string manipulation libraries\nstringx = require('pl.stringx')\n-- Define response cleaning functions\nfunction cleanResponse(response)\n  if not response then return '' end\n  -- Remove common response markers and whitespace\n  response = stringx.replace(response, '>', '')\n  response = stringx.replace(response, '<', '')\n  response = stringx.replace(response, '\\r\\n', '')\n  response = stringx.replace(response, '\\n', '')\n  response = stringx.replace(response, '\\r', '')\n  response = stringx.strip(response)\n  return response\nend\nfunction parseCSVResponse(response)\n  if not response or response == '' then return {} end\n  local cleanResp = cleanResponse(response)\n  return stringx.split(cleanResp, ',')\nend\nfunction extractNumericValue(response, position)\n  local parts = parseCSVResponse(response)\n  if #parts >= (position or 2) then\n    return tonumber(stringx.strip(parts[position or 2]))\n  else\n    return nil\n  end\nend\nfunction validateNumeric(value, min, max)\n  return value and value >= (min or -math.huge) and value <= (max or math.huge)\nend",
          "enter_script": "-- Log TCP communication cycle\n-- print('Starting TCP ASCII command cycle')",
          "exit_script": "-- Calculate machine utilization from collected data\nlocal execution = cache('./Execution', 'IDLE')\nlocal alarmCount = cache('./AlarmCount', 0)\nlocal spindleLoad = cache('./SpindleLoad', 0)\nlocal currentTime = os.time()\nlocal lastTime = cache('last_util_time', currentTime)\nlocal runTime = cache('total_run_time', 0)\n-- Update run time if machine is executing\nif execution == 'ACTIVE' and currentTime > lastTime then\n  runTime = runTime + (currentTime - lastTime)\n  set('total_run_time', runTime)\nend\nset('last_util_time', currentTime)\n-- Calculate utilization percentage over last hour\nlocal utilization = (runTime / 3600) * 100\nif utilization <= 100 then\n  emit('./MachineUtilization', math.floor(utilization * 10) / 10)\nend\n-- Calculate machine health score\nlocal healthScore = 100\nif alarmCount > 0 then healthScore = healthScore - (alarmCount * 10) end\nif spindleLoad > 90 then healthScore = healthScore - 20 end\nif execution == 'FAULT' then healthScore = healthScore - 50 end\nemit('./MachineHealthScore', math.max(0, healthScore))",
          "items": [
            {
              "name": "SystemAvailability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate system availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal execution = cache('./Execution', 'UNAVAILABLE')\nlocal alarmCount = cache('./AlarmCount', 0)\nif not isConnected then\n  return 'Unavailable'\nelseif alarmCount > 0 then\n  return 'Fault'\nelseif execution == 'ACTIVE' then\n  return 'Available'\nelse\n  return 'Idle'\nend",
              "sink": {
                "mtconnect": "Device[name=machine1]/Availability[category=Event]"
              }
            },
            {
              "name": "SerialNumber",
              "enabled": true,
              "address": "?Q100",
              "rbe": true,
              "every": 20,
              "script": "-- Get machine serial number (Haas Q100 command)\nlocal cleanResp = cleanResponse(result)\nlocal value = extractNumericValue(cleanResp, 2)\nif value then\n  return tostring(value)\nelse\n  return cleanResp\nend"
            },
            {
              "name": "PartCount",
              "enabled": true,
              "address": "?Q300",
              "rbe": true,
              "every": 2,
              "script": "-- Get total part count (Haas Q300 command)\nlocal value = extractNumericValue(result, 2)\nif value and validateNumeric(value, 0, 999999) then\n  return math.floor(value)\nelse\n  return cache('./PartCount', 0)\nend",
              "sink": {
                "mtconnect": "Device[name=machine1]/Controller/PartCount[category=Event]"
              }
            },
            {
              "name": "Execution",
              "enabled": true,
              "address": "?Q500",
              "rbe": true,
              "every": 1,
              "script": "-- Get execution status (Haas Q500 command)\nlocal parts = parseCSVResponse(result)\nif #parts >= 3 then\n  local status = stringx.strip(parts[3])\n  local statusMap = {\n    ['0'] = 'IDLE',\n    ['1'] = 'ACTIVE',\n    ['2'] = 'INTERRUPTED',\n    ['3'] = 'FEED_HOLD',\n    ['4'] = 'STOPPED'\n  }\n  return statusMap[status] or status\nelse\n  return 'UNAVAILABLE'\nend",
              "sink": {
                "mtconnect": "Device[name=machine1]/Controller/Execution[category=Event]"
              }
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "timebaseWsSource": {
      "description": "Subscribes to data from a Timescale Historian via a WebSocket",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Port",
          "default": 4511
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/timebaseWsItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "timebaseWsSource1",
          "enabled": true,
          "connector": "timebaseWs",
          "scan_interval": 500,
          "rbe": true,
          "lang_script": "Lua",
          "address": "localhost",
          "port": 4511,
          "items": [
            {
              "name": "plcExecution",
              "enabled": true,
              "group": "MQTT Data",
              "address": "dime/eipSource1/Execution/Data",
              "rbe": true,
              "every": 1,
              "sink": {
                "mtconnect": "Device[name=line1]/Controller/Execution[category=Event]"
              }
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "udpServerSource": {
      "description": "Reads data from a UDP socket",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "IP address, hostname is not accepted"
        },
        "port": {
          "type": "integer",
          "description": "Port to listen on",
          "default": 2323
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address", "port"],
      "examples": [
        {
          "name": "udpDataServer",
          "enabled": true,
          "connector": "udpServer",
          "scan_interval": 100,
          "rbe": true,
          "lang_script": "Lua",
          "address": "0.0.0.0",
          "port": 2323,
          "init_script": "-- Initialize UDP Server data processing\nprint('UDP Server connector initialized on port 2323')\n-- Import required libraries\nstruct = require('struct')\njson = require('json')\nstringx = require('pl.stringx')\n-- Define protocol identifiers\nPROTOCOL_SENSOR_DATA = 0x01\nPROTOCOL_ALARM_DATA = 0x02\nPROTOCOL_STATUS_DATA = 0x03\nPROTOCOL_PRODUCTION_DATA = 0x04\nPROTOCOL_TEXT_MESSAGE = 0x05\n-- Data validation functions\nfunction validateTemperature(temp)\n  return temp and temp >= -50 and temp <= 200\nend\nfunction validatePressure(pressure)\n  return pressure and pressure >= 0 and pressure <= 1000\nend\nfunction bytesToHex(bytes)\n  local hex = ''\n  for i = 1, #bytes do\n    hex = hex .. string.format('%02X ', bytes[i])\n  end\n  return hex:sub(1, -2)\nend\nfunction bytesToString(bytes)\n  local str = ''\n  for i = 1, #bytes do\n    if bytes[i] > 0 and bytes[i] < 127 then\n      str = str .. string.char(bytes[i])\n    end\n  end\n  return str\nend",
          "enter_script": "-- Log UDP message processing cycle\n-- print('UDP Server processing cycle started')",
          "exit_script": "-- Calculate UDP traffic statistics\nlocal messagesReceived = cache('total_messages', 0)\nlocal bytesReceived = cache('total_bytes', 0)\nlocal currentTime = os.time()\nlocal lastTime = cache('last_stats_time', currentTime)\nif currentTime > lastTime then\n  local deltaTime = currentTime - lastTime\n  local messagesPerSecond = deltaTime > 0 and (messagesReceived / deltaTime) or 0\n  local bytesPerSecond = deltaTime > 0 and (bytesReceived / deltaTime) or 0\n  emit('./UDPStats/messagesPerSecond', math.floor(messagesPerSecond * 10) / 10)\n  emit('./UDPStats/bytesPerSecond', math.floor(bytesPerSecond))\n  emit('./UDPStats/totalMessages', messagesReceived)\n  emit('./UDPStats/totalBytes', bytesReceived)\nend",
          "items": [
            {
              "name": "RawMessageData",
              "enabled": true,
              "address": "message",
              "rbe": false,
              "every": 1,
              "script": "-- Process raw UDP message data\nif not result or #result == 0 then return nil end\n-- Update statistics\nlocal totalMessages = cache('total_messages', 0) + 1\nlocal totalBytes = cache('total_bytes', 0) + #result\nset('total_messages', totalMessages)\nset('total_bytes', totalBytes)\n-- Convert to hex string for debugging\nlocal hexData = bytesToHex(result)\nlocal messageLength = #result\n-- Emit raw data details\nemit('./RawMessageData/length', messageLength)\nemit('./RawMessageData/hex', hexData)\n-- Try to determine protocol type from first byte\nif messageLength > 0 then\n  local protocolType = result[1]\n  emit('./RawMessageData/protocolType', protocolType)\n  return 'Protocol: ' .. protocolType .. ', Length: ' .. messageLength\nelse\n  return 'Empty message'\nend"
            },
            {
              "name": "SensorDataProtocol",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Process sensor data protocol (Type 0x01)\nif not result or #result < 13 then return nil end\n-- Check if this is sensor data protocol\nif result[1] ~= PROTOCOL_SENSOR_DATA then return nil end\n-- Parse binary sensor data packet\n-- Format: [Protocol][SensorID][Temperature][Pressure][Humidity][Timestamp]\n--         1 byte   4 bytes    4 bytes      4 bytes    2 bytes   4 bytes\nlocal sensorId = struct.unpack('<I', string.char(result[2], result[3], result[4], result[5]))\nlocal temperature = struct.unpack('<f', string.char(result[6], result[7], result[8], result[9]))\nlocal pressure = struct.unpack('<f', string.char(result[10], result[11], result[12], result[13]))\nlocal humidity = 0\nlocal timestamp = os.time()\nif #result >= 15 then\n  humidity = struct.unpack('<H', string.char(result[14], result[15]))\nend\nif #result >= 19 then\n  timestamp = struct.unpack('<I', string.char(result[16], result[17], result[18], result[19]))\nend\n-- Validate sensor data\nif not validateTemperature(temperature) then return nil end\nif not validatePressure(pressure) then return nil end\n-- Emit individual sensor readings\nemit('./SensorDataProtocol/sensor' .. sensorId .. '/temperature', math.floor(temperature * 10) / 10)\nemit('./SensorDataProtocol/sensor' .. sensorId .. '/pressure', math.floor(pressure * 10) / 10)\nemit('./SensorDataProtocol/sensor' .. sensorId .. '/humidity', humidity)\nemit('./SensorDataProtocol/sensor' .. sensorId .. '/timestamp', timestamp)\nreturn 'Sensor ' .. sensorId .. ': T=' .. math.floor(temperature) .. '°C, P=' .. math.floor(pressure) .. ' PSI'"
            },
            {
              "name": "AlarmDataProtocol",
              "enabled": true,
              "address": "message",
              "rbe": false,
              "every": 1,
              "script": "-- Process alarm data protocol (Type 0x02)\nif not result or #result < 10 then return nil end\n-- Check if this is alarm data protocol\nif result[1] ~= PROTOCOL_ALARM_DATA then return nil end\n-- Parse alarm packet\n-- Format: [Protocol][DeviceID][AlarmCode][Severity][Timestamp]\n--         1 byte    4 bytes   2 bytes     1 byte   4 bytes\nlocal deviceId = struct.unpack('<I', string.char(result[2], result[3], result[4], result[5]))\nlocal alarmCode = struct.unpack('<H', string.char(result[6], result[7]))\nlocal severity = result[8]\nlocal timestamp = os.time()\nif #result >= 12 then\n  timestamp = struct.unpack('<I', string.char(result[9], result[10], result[11], result[12]))\nend\n-- Map severity levels\nlocal severityMap = {\n  [1] = 'INFO',\n  [2] = 'WARNING',\n  [3] = 'ERROR',\n  [4] = 'CRITICAL'\n}\nlocal severityText = severityMap[severity] or 'UNKNOWN'\n-- Map common alarm codes\nlocal alarmMap = {\n  [100] = 'Temperature_High',\n  [101] = 'Pressure_Low',\n  [102] = 'Communication_Error',\n  [103] = 'Power_Supply_Fault',\n  [104] = 'Safety_Circuit_Open',\n  [105] = 'Motor_Overload'\n}\nlocal alarmText = alarmMap[alarmCode] or ('Alarm_' .. alarmCode)\n-- Emit alarm details\nemit('./AlarmDataProtocol/device' .. deviceId .. '/alarmCode', alarmCode)\nemit('./AlarmDataProtocol/device' .. deviceId .. '/severity', severityText)\nemit('./AlarmDataProtocol/device' .. deviceId .. '/alarmText', alarmText)\nemit('./AlarmDataProtocol/device' .. deviceId .. '/timestamp', timestamp)\nreturn '[' .. severityText .. '] Device ' .. deviceId .. ': ' .. alarmText"
            },
            {
              "name": "StatusDataProtocol",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Process status data protocol (Type 0x03)\nif not result or #result < 9 then return nil end\n-- Check if this is status data protocol\nif result[1] ~= PROTOCOL_STATUS_DATA then return nil end\n-- Parse status packet\n-- Format: [Protocol][DeviceID][Status][OperatingHours][Timestamp]\n--         1 byte    4 bytes   1 byte  2 bytes        4 bytes (optional)\nlocal deviceId = struct.unpack('<I', string.char(result[2], result[3], result[4], result[5]))\nlocal status = result[6]\nlocal operatingHours = struct.unpack('<H', string.char(result[7], result[8]))\nlocal timestamp = os.time()\nif #result >= 12 then\n  timestamp = struct.unpack('<I', string.char(result[9], result[10], result[11], result[12]))\nend\n-- Map status codes\nlocal statusMap = {\n  [0] = 'Offline',\n  [1] = 'Online',\n  [2] = 'Running',\n  [3] = 'Stopped',\n  [4] = 'Maintenance',\n  [5] = 'Fault'\n}\nlocal statusText = statusMap[status] or 'Unknown'\n-- Emit status information\nemit('./StatusDataProtocol/device' .. deviceId .. '/status', statusText)\nemit('./StatusDataProtocol/device' .. deviceId .. '/operatingHours', operatingHours)\nemit('./StatusDataProtocol/device' .. deviceId .. '/timestamp', timestamp)\nreturn 'Device ' .. deviceId .. ': ' .. statusText .. ' (' .. operatingHours .. 'h)'"
            },
            {
              "name": "ProductionDataProtocol",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Process production data protocol (Type 0x04)\nif not result or #result < 15 then return nil end\n-- Check if this is production data protocol\nif result[1] ~= PROTOCOL_PRODUCTION_DATA then return nil end\n-- Parse production packet\n-- Format: [Protocol][LineID][PartCount][GoodParts][RejectParts][CycleTime]\n--         1 byte    4 bytes  4 bytes    4 bytes    4 bytes      2 bytes\nlocal lineId = struct.unpack('<I', string.char(result[2], result[3], result[4], result[5]))\nlocal partCount = struct.unpack('<I', string.char(result[6], result[7], result[8], result[9]))\nlocal goodParts = struct.unpack('<I', string.char(result[10], result[11], result[12], result[13]))\nlocal rejectParts = struct.unpack('<I', string.char(result[14], result[15], result[16], result[17]))\nlocal cycleTime = 0\nif #result >= 19 then\n  cycleTime = struct.unpack('<H', string.char(result[18], result[19]))\nend\n-- Calculate quality metrics\nlocal qualityRate = partCount > 0 and (goodParts / partCount * 100) or 100\nlocal rejectRate = partCount > 0 and (rejectParts / partCount * 100) or 0\n-- Emit production data\nemit('./ProductionDataProtocol/line' .. lineId .. '/partCount', partCount)\nemit('./ProductionDataProtocol/line' .. lineId .. '/goodParts', goodParts)\nemit('./ProductionDataProtocol/line' .. lineId .. '/rejectParts', rejectParts)\nemit('./ProductionDataProtocol/line' .. lineId .. '/cycleTime', cycleTime)\nemit('./ProductionDataProtocol/line' .. lineId .. '/qualityRate', math.floor(qualityRate * 10) / 10)\nemit('./ProductionDataProtocol/line' .. lineId .. '/rejectRate', math.floor(rejectRate * 10) / 10)\nreturn 'Line ' .. lineId .. ': ' .. partCount .. ' parts, Quality: ' .. math.floor(qualityRate) .. '%'"
            },
            {
              "name": "TextMessageProtocol",
              "enabled": true,
              "address": "message",
              "rbe": false,
              "every": 1,
              "script": "-- Process text message protocol (Type 0x05)\nif not result or #result < 2 then return nil end\n-- Check if this is text message protocol\nif result[1] ~= PROTOCOL_TEXT_MESSAGE then return nil end\n-- Extract text message (remaining bytes after protocol identifier)\nlocal textBytes = {}\nfor i = 2, #result do\n  table.insert(textBytes, result[i])\nend\nlocal textMessage = bytesToString(textBytes)\n-- Clean up text message\ntextMessage = string.gsub(textMessage, '^%s*(.-)%s*$', '%1')\nif textMessage == '' then return nil end\n-- Try to parse as JSON if it looks like JSON\nif string.sub(textMessage, 1, 1) == '{' then\n  local success, data = pcall(json.decode, textMessage)\n  if success and data then\n    -- Process JSON message\n    local messageType = data.type or 'unknown'\n    local source = data.source or 'unknown'\n    local content = data.message or data.content or textMessage\n    emit('./TextMessageProtocol/json/' .. messageType, content)\n    emit('./TextMessageProtocol/json/source', source)\n    return '[JSON] ' .. messageType .. ' from ' .. source\n  end\nend\n-- Process as plain text\nemit('./TextMessageProtocol/text/message', textMessage)\nreturn '[TEXT] ' .. textMessage"
            },
            {
              "name": "CSVDataFormat",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Process CSV format data over UDP\nif not result or #result < 10 then return nil end\n-- Convert bytes to string\nlocal csvData = bytesToString(result)\nif csvData == '' then return nil end\n-- Check if it looks like CSV (contains commas)\nif not string.find(csvData, ',') then return nil end\n-- Parse CSV data\nlocal fields = stringx.split(csvData, ',')\nif #fields < 3 then return nil end\n-- Extract common CSV format: DeviceID,Timestamp,Value1,Value2,Value3...\nlocal deviceId = stringx.strip(fields[1])\nlocal timestamp = tonumber(stringx.strip(fields[2])) or os.time()\nlocal values = {}\nfor i = 3, #fields do\n  local value = tonumber(stringx.strip(fields[i]))\n  if value then\n    table.insert(values, value)\n    emit('./CSVDataFormat/' .. deviceId .. '/value' .. (i-2), value)\n  end\nend\nemit('./CSVDataFormat/' .. deviceId .. '/timestamp', timestamp)\nreturn deviceId .. ': ' .. #values .. ' values received'"
            },
            {
              "name": "ModbusUDPSimulation",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Simulate Modbus-like protocol over UDP\nif not result or #result < 8 then return nil end\n-- Simple Modbus-like packet: [SlaveID][Function][StartAddr][NumRegs][Data...]\nlocal slaveId = result[1]\nlocal functionCode = result[2]\nlocal startAddr = struct.unpack('<H', string.char(result[3], result[4]))\nlocal numRegs = struct.unpack('<H', string.char(result[5], result[6]))\n-- Only process read holding registers response (function 3)\nif functionCode ~= 3 or #result < 7 + (numRegs * 2) then return nil end\nlocal byteCount = result[7]\nif byteCount ~= (numRegs * 2) then return nil end\n-- Extract register values\nlocal registers = {}\nfor i = 1, numRegs do\n  local regOffset = 8 + ((i-1) * 2)\n  if regOffset + 1 <= #result then\n    local regValue = struct.unpack('<H', string.char(result[regOffset], result[regOffset + 1]))\n    table.insert(registers, regValue)\n    emit('./ModbusUDPSimulation/slave' .. slaveId .. '/register' .. (startAddr + i - 1), regValue)\n  end\nend\nreturn 'Slave ' .. slaveId .. ': ' .. numRegs .. ' registers from address ' .. startAddr"
            },
            {
              "name": "HeartbeatMessages",
              "enabled": true,
              "address": "message",
              "rbe": false,
              "every": 1,
              "script": "-- Process simple heartbeat messages\nif not result or #result < 5 then return nil end\n-- Simple heartbeat: 'ALIVE' or 'PING'\nlocal message = bytesToString(result)\nif message == 'ALIVE' or message == 'PING' then\n  local currentTime = os.time()\n  emit('./HeartbeatMessages/lastHeartbeat', currentTime)\n  emit('./HeartbeatMessages/status', 'Online')\n  return 'Heartbeat received at ' .. os.date('%H:%M:%S', currentTime)\nelse\n  return nil\nend"
            },
            {
              "name": "BinaryTelemetry",
              "enabled": true,
              "address": "message",
              "rbe": true,
              "every": 1,
              "script": "-- Process binary telemetry data\nif not result or #result < 16 then return nil end\n-- Custom telemetry format: [Header][DeviceID][Voltage][Current][Power][Status]\n--                          2 bytes  2 bytes   4 bytes  4 bytes  4 bytes 1 byte\nlocal header = struct.unpack('<H', string.char(result[1], result[2]))\nif header ~= 0xAABB then return nil end  -- Check for valid header\nlocal deviceId = struct.unpack('<H', string.char(result[3], result[4]))\nlocal voltage = struct.unpack('<f', string.char(result[5], result[6], result[7], result[8]))\nlocal current = struct.unpack('<f', string.char(result[9], result[10], result[11], result[12]))\nlocal power = struct.unpack('<f', string.char(result[13], result[14], result[15], result[16]))\nlocal status = #result >= 17 and result[17] or 0\n-- Validate electrical readings\nif voltage < 0 or voltage > 600 then return nil end\nif current < 0 or current > 500 then return nil end\nif power < 0 or power > 300 then return nil end\n-- Emit telemetry data\nemit('./BinaryTelemetry/device' .. deviceId .. '/voltage', math.floor(voltage * 10) / 10)\nemit('./BinaryTelemetry/device' .. deviceId .. '/current', math.floor(current * 100) / 100)\nemit('./BinaryTelemetry/device' .. deviceId .. '/power', math.floor(power * 100) / 100)\nemit('./BinaryTelemetry/device' .. deviceId .. '/status', status)\nreturn 'Device ' .. deviceId .. ': ' .. math.floor(voltage) .. 'V, ' .. math.floor(current) .. 'A, ' .. math.floor(power) .. 'W'"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "smartPacSource": {
      "description": "Reads data from a Wintriss SmartPAC controller",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Hostname or IP address"
        },
        "port": {
          "type": "integer",
          "description": "Port",
          "default": 1007
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "smartPacPress1",
          "enabled": true,
          "connector": "smartPac",
          "scan_interval": 1000,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.180",
          "port": 1007,
          "init_script": "-- Initialize SmartPAC Press monitoring\nprint('SmartPAC connector initialized')\n-- Define press state mappings\nPressStates = {\n  [0] = 'Stopped',\n  [1] = 'Running',\n  [2] = 'Maintenance',\n  [3] = 'Setup',\n  [4] = 'Fault'\n}\n-- Define die protection status\nDieStates = {\n  [0] = 'OK',\n  [1] = 'Misfeed',\n  [2] = 'Part_Stuck',\n  [3] = 'Double_Feed',\n  [4] = 'No_Part'\n}\n-- Force conversion factor (assuming force in tons)\nLBS_PER_TON = 2000\n-- Initialize counters\ntotalStrokes = 0\ngoodParts = 0\nrejectParts = 0",
          "enter_script": "-- Log press monitoring cycle\n-- print('SmartPAC data collection cycle started')",
          "exit_script": "-- Calculate press efficiency metrics\nlocal currentStrokes = cache('./StrokeCount', 0)\nlocal currentGood = cache('./GoodPartCount', 0)\nlocal currentRejects = cache('./RejectCount', 0)\nlocal isRunning = cache('./PressRunning', false)\n-- Calculate efficiency\nlocal totalParts = currentGood + currentRejects\nlocal efficiency = totalParts > 0 and (currentGood / totalParts * 100) or 100\nlocal strokesPerMinute = 0\nlocal currentTime = os.time()\nlocal lastTime = cache('last_efficiency_time', currentTime)\nif currentTime > lastTime then\n  local deltaTime = (currentTime - lastTime) / 60  -- Convert to minutes\n  local lastStrokes = cache('last_stroke_count', 0)\n  strokesPerMinute = deltaTime > 0 and ((currentStrokes - lastStrokes) / deltaTime) or 0\nend\nset('last_efficiency_time', currentTime)\nset('last_stroke_count', currentStrokes)\n-- Emit calculated metrics\nemit('./PressEfficiency', math.floor(efficiency * 10) / 10)\nemit('./StrokesPerMinute', math.floor(strokesPerMinute * 10) / 10)\nlocal utilizationPercent = isRunning and 100 or 0\nemit('./Utilization', utilizationPercent)",
          "items": [
            {
              "name": "SystemAvailability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate press availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal pressRunning = cache('./PressRunning', false)\nlocal hasFault = cache('./FaultActive', false)\nlocal safetyOK = cache('./SafetyStatus', true)\nif not isConnected then\n  return 'Unavailable'\nelseif hasFault or not safetyOK then\n  return 'Fault'\nelseif pressRunning then\n  return 'Available'\nelse\n  return 'Stopped'\nend",
              "sink": {
                "mtconnect": "Device[name=press1]/Availability[category=Event]"
              }
            },
            {
              "name": "PressType",
              "enabled": true,
              "rbe": true,
              "every": 10,
              "script": "-- Press type identification\nif not result or #result < 1 then return 'Unknown' end\nlocal pressType = tostring(result[1] or 'Unknown')\nlocal typeMap = {\n  ['1'] = 'Mechanical',\n  ['2'] = 'Hydraulic',\n  ['3'] = 'Servo',\n  ['4'] = 'Pneumatic'\n}\nreturn typeMap[pressType] or pressType"
            },
            {
              "name": "PressName",
              "enabled": true,
              "rbe": true,
              "every": 10,
              "script": "-- Press identification name\nif not result or #result < 2 then return 'Unknown' end\nlocal pressName = tostring(result[2] or 'Unknown')\npressName = string.gsub(pressName, '^%s*(.-)%s*$', '%1')\nreturn pressName ~= '' and pressName or 'Unnamed_Press'"
            },
            {
              "name": "PressRunning",
              "enabled": true,
              "rbe": true,
              "every": 1,
              "script": "-- Press running status\nif not result or #result < 3 then return false end\nlocal running = result[3] == 1 or result[3] == true\nreturn running",
              "sink": {
                "mtconnect": "Device[name=press1]/Controller/Execution[category=Event]"
              }
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "xmlWebScraperSource": {
      "description": "Reads data from an XML web page",
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "description": "Web page address",
          "default": "http://localhost/"
        },
        "namespaces": {
          "type": "object",
          "description": "Namespace mappings",
          "additionalProperties": {
            "type": "string"
          }
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["uri"],
      "examples": [
        {
          "name": "xmlDataScraper",
          "enabled": true,
          "connector": "xmlWebScraper",
          "scan_interval": 5000,
          "rbe": true,
          "lang_script": "Lua",
          "uri": "http://mtconnect.mazakcorp.com:5719/current",
          "namespaces": {
            "mt": "urn:mtconnect.org:MTConnectStreams:1.2",
            "m": "urn:mtconnect.org:MTConnectDevices:1.2"
          },
          "init_script": "-- Initialize XML Web Scraper\nprint('XML Web Scraper connector initialized')\n-- Import additional libraries\nstringx = require('pl.stringx')\n-- Define data validation functions\nfunction validateNumeric(value, min, max)\n  local num = tonumber(value)\n  return num and num >= (min or -math.huge) and num <= (max or math.huge) and num or nil\nend\nfunction cleanText(text)\n  if not text then return 'Unknown' end\n  text = string.gsub(text, '^%s*(.-)%s*$', '%1')\n  return text ~= '' and text or 'Unknown'\nend\nfunction parseTimestamp(timeStr)\n  if not timeStr then return os.time() end\n  -- Simple timestamp parsing - could be enhanced\n  return timeStr\nend",
          "enter_script": "-- Log XML scraping cycle\n-- print('Starting XML data scraping cycle')",
          "exit_script": "-- Calculate overall system health from scraped data\nlocal connectedSystems = 0\nlocal totalSystems = 5\nlocal avgTemp = 0\nlocal tempCount = 0\n-- Check system connections\nfor i = 1, totalSystems do\n  if cache('./System' .. i .. '/status', 'offline') == 'online' then\n    connectedSystems = connectedSystems + 1\n  end\n  local temp = cache('./System' .. i .. '/temperature', nil)\n  if temp then\n    avgTemp = avgTemp + temp\n    tempCount = tempCount + 1\n  end\nend\nif tempCount > 0 then\n  avgTemp = avgTemp / tempCount\nend\nlocal systemHealth = (connectedSystems / totalSystems) * 100\nemit('./SystemHealth/connectedSystems', connectedSystems)\nemit('./SystemHealth/healthPercentage', math.floor(systemHealth))\nemit('./SystemHealth/averageTemperature', math.floor(avgTemp * 10) / 10)",
          "item_script": "-- Default processing for XML elements\nlocal elementText = result and result.InnerText or ''\n-- Clean and validate the text content\nlocal cleanedText = cleanText(elementText)\nreturn cleanedText",
          "items": [
            {
              "name": "DeviceAvailability",
              "enabled": true,
              "address": "//mt:DeviceStream[@name='HCN001']//mt:Availability",
              "rbe": true,
              "every": 1,
              "script": "-- Extract MTConnect device availability\nif not result then return nil end\nlocal availability = result.InnerText or 'UNAVAILABLE'\nlocal timestamp = result:GetAttribute('timestamp')\nif timestamp then\n  emit('./DeviceAvailability/timestamp', timestamp)\nend\nreturn string.upper(availability)",
              "sink": {
                "mtconnect": "Device[name=machine1]/Availability[category=Event]"
              }
            },
            {
              "name": "SpindleSpeed",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='c2spindlespeed']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract spindle speed from MTConnect\nif not result then return nil end\nlocal speed = validateNumeric(result.InnerText, 0, 10000)\nlocal timestamp = result:GetAttribute('timestamp')\nlocal sequence = result:GetAttribute('sequence')\nif timestamp then\n  emit('./SpindleSpeed/timestamp', timestamp)\nend\nif sequence then\n  emit('./SpindleSpeed/sequence', tonumber(sequence) or 0)\nend\nreturn speed and math.floor(speed) or nil",
              "sink": {
                "mtconnect": "Device[name=machine1]/Controller/SpindleSpeed[category=Sample]"
              }
            },
            {
              "name": "Execution",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='execution']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract execution status\nif not result then return nil end\nlocal execution = string.upper(result.InnerText or 'UNAVAILABLE')\nlocal timestamp = result:GetAttribute('timestamp')\nif timestamp then\n  emit('./Execution/timestamp', timestamp)\nend\n-- Map execution states\nlocal stateMap = {\n  ['READY'] = 'Ready',\n  ['ACTIVE'] = 'Active',\n  ['INTERRUPTED'] = 'Interrupted',\n  ['FEED_HOLD'] = 'Feed_Hold',\n  ['STOPPED'] = 'Stopped'\n}\nreturn stateMap[execution] or execution"
            },
            {
              "name": "ControllerMode",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='mode']",
              "rbe": true,
              "every": 2,
              "script": "-- Extract controller mode\nif not result then return nil end\nlocal mode = string.upper(result.InnerText or 'UNAVAILABLE')\nlocal modeMap = {\n  ['AUTOMATIC'] = 'Automatic',\n  ['MANUAL'] = 'Manual',\n  ['SEMI_AUTOMATIC'] = 'Semi_Automatic',\n  ['MDI'] = 'Manual_Data_Input'\n}\nreturn modeMap[mode] or mode"
            },
            {
              "name": "ActiveProgram",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='program']",
              "rbe": true,
              "every": 3,
              "script": "-- Extract active program name\nif not result then return nil end\nlocal program = cleanText(result.InnerText)\nlocal timestamp = result:GetAttribute('timestamp')\nif timestamp then\n  emit('./ActiveProgram/timestamp', timestamp)\nend\nreturn program"
            },
            {
              "name": "PartCount",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='partcount']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract part count\nif not result then return nil end\nlocal count = validateNumeric(result.InnerText, 0, 999999)\nlocal timestamp = result:GetAttribute('timestamp')\nif timestamp then\n  emit('./PartCount/timestamp', timestamp)\nend\nreturn count and math.floor(count) or 0"
            },
            {
              "name": "XAxisPosition",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='x1pos']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract X-axis position\nif not result then return nil end\nlocal position = validateNumeric(result.InnerText, -1000, 1000)\nlocal units = result:GetAttribute('units') or 'MILLIMETER'\nif units then\n  emit('./XAxisPosition/units', units)\nend\nreturn position and (math.floor(position * 1000) / 1000) or nil"
            },
            {
              "name": "YAxisPosition",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='y1pos']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract Y-axis position\nif not result then return nil end\nlocal position = validateNumeric(result.InnerText, -1000, 1000)\nreturn position and (math.floor(position * 1000) / 1000) or nil"
            },
            {
              "name": "ZAxisPosition",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='z1pos']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract Z-axis position\nif not result then return nil end\nlocal position = validateNumeric(result.InnerText, -500, 500)\nreturn position and (math.floor(position * 1000) / 1000) or nil"
            },
            {
              "name": "ToolNumber",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='tool']",
              "rbe": true,
              "every": 2,
              "script": "-- Extract current tool number\nif not result then return nil end\nlocal tool = validateNumeric(result.InnerText, 0, 200)\nreturn tool and math.floor(tool) or 0"
            },
            {
              "name": "FeedRate",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='feedrate']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract feed rate\nif not result then return nil end\nlocal feedRate = validateNumeric(result.InnerText, 0, 1000)\nlocal units = result:GetAttribute('units') or 'MILLIMETER/MINUTE'\nif units then\n  emit('./FeedRate/units', units)\nend\nreturn feedRate and (math.floor(feedRate * 100) / 100) or 0"
            },
            {
              "name": "SpindleLoad",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='spindleload']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract spindle load percentage\nif not result then return nil end\nlocal load = validateNumeric(result.InnerText, 0, 200)\nreturn load and (math.floor(load * 10) / 10) or 0"
            },
            {
              "name": "SystemAlarms",
              "enabled": true,
              "address": "//mt:Condition[@level='FAULT' or @level='WARNING']",
              "rbe": false,
              "every": 1,
              "script": "-- Extract system alarms and conditions\nif not result then return nil end\nlocal level = result:GetAttribute('level') or 'NORMAL'\nlocal type = result:GetAttribute('type') or 'SYSTEM'\nlocal dataItemId = result:GetAttribute('dataItemId') or 'unknown'\nlocal nativeCode = result:GetAttribute('nativeCode') or ''\nlocal text = cleanText(result.InnerText)\nlocal timestamp = result:GetAttribute('timestamp')\n-- Emit alarm details\nemit('./SystemAlarms/' .. dataItemId .. '/level', level)\nemit('./SystemAlarms/' .. dataItemId .. '/type', type)\nemit('./SystemAlarms/' .. dataItemId .. '/nativeCode', nativeCode)\nemit('./SystemAlarms/' .. dataItemId .. '/text', text)\nif timestamp then\n  emit('./SystemAlarms/' .. dataItemId .. '/timestamp', timestamp)\nend\nreturn '[' .. level .. '] ' .. type .. ': ' .. text"
            },
            {
              "name": "DeviceInformation",
              "enabled": true,
              "address": "//mt:DeviceStream[@name='HCN001']/@uuid",
              "rbe": true,
              "every": 10,
              "script": "-- Extract device UUID\nif not result then return nil end\nlocal uuid = tostring(result)\nreturn uuid ~= '' and uuid or 'Unknown'"
            },
            {
              "name": "DataItemCount",
              "enabled": true,
              "address": "count(//mt:Sample | //mt:Event | //mt:Condition)",
              "rbe": true,
              "every": 5,
              "script": "-- Count total data items in response\nlocal count = tonumber(result)\nreturn count or 0"
            },
            {
              "name": "LastUpdateSequence",
              "enabled": true,
              "address": "//mt:MTConnectStreams/@lastSequence",
              "rbe": true,
              "every": 1,
              "script": "-- Extract last sequence number\nlocal sequence = tonumber(result)\nreturn sequence or 0"
            },
            {
              "name": "PowerConsumption",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='power']",
              "rbe": true,
              "every": 3,
              "script": "-- Extract power consumption\nif not result then return nil end\nlocal power = validateNumeric(result.InnerText, 0, 100)\nlocal units = result:GetAttribute('units') or 'KILOWATT'\nif units then\n  emit('./PowerConsumption/units', units)\nend\nreturn power and (math.floor(power * 100) / 100) or 0"
            },
            {
              "name": "Temperature",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='temp']",
              "rbe": true,
              "every": 2,
              "script": "-- Extract temperature reading\nif not result then return nil end\nlocal temp = validateNumeric(result.InnerText, -50, 200)\nlocal units = result:GetAttribute('units') or 'CELSIUS'\nif units then\n  emit('./Temperature/units', units)\nend\nreturn temp and (math.floor(temp * 10) / 10) or nil"
            },
            {
              "name": "CycleTime",
              "enabled": true,
              "address": "//mt:Sample[@dataItemId='cycletime']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract cycle time\nif not result then return nil end\nlocal cycleTime = validateNumeric(result.InnerText, 0, 3600)\nlocal units = result:GetAttribute('units') or 'SECOND'\nif units then\n  emit('./CycleTime/units', units)\nend\nreturn cycleTime and (math.floor(cycleTime * 100) / 100) or 0"
            },
            {
              "name": "WorkpieceCounter",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='workpiece']",
              "rbe": true,
              "every": 1,
              "script": "-- Extract workpiece counter\nif not result then return nil end\nlocal workpiece = result.InnerText or ''\nlocal parts = string.match(workpiece, 'count:(%d+)')\nif parts then\n  return tonumber(parts)\nelse\n  return validateNumeric(workpiece, 0, 999999) or 0\nend"
            },
            {
              "name": "ToolLife",
              "enabled": true,
              "address": "//mt:Event[@dataItemId='toollife']",
              "rbe": true,
              "every": 5,
              "script": "-- Extract tool life information\nif not result then return nil end\nlocal toolLife = result.InnerText or ''\n-- Try to extract percentage from tool life string\nlocal percentage = string.match(toolLife, '(%d+)%%')\nif percentage then\n  return tonumber(percentage)\nelse\n  -- Try to extract remaining count\n  local remaining = string.match(toolLife, 'remaining:(%d+)')\n  if remaining then\n    emit('./ToolLife/remaining', tonumber(remaining))\n    return 'Remaining: ' .. remaining\n  else\n    return cleanText(toolLife)\n  end\nend"
            },
            {
              "name": "SystemStatus",
              "enabled": true,
              "address": "//mt:MTConnectStreams/@instanceId",
              "rbe": true,
              "every": 10,
              "script": "-- Extract system instance ID for health monitoring\nlocal instanceId = tonumber(result)\nif instanceId then\n  -- Store for system health calculation\n  emit('./SystemStatus/instanceId', instanceId)\n  return 'Instance: ' .. instanceId\nelse\n  return 'Unknown Instance'\nend"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    },
    "yaskawaSource": {
      "description": "Reads data from DX200, YRC1000, YRC1000 Micro Yaskawa controllers",
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "Robot IP address or hostname"
        },
        "items": {
          "type": "array",
          "description": "List of items for the connector",
          "items": { "$ref": "#/definitions/baseItem" }
        }
      },
      "required": ["address"],
      "examples": [
        {
          "name": "yaskawaRobot1",
          "enabled": true,
          "connector": "yaskawa",
          "scan_interval": 1000,
          "rbe": true,
          "lang_script": "Lua",
          "address": "192.168.1.200",
          "init_script": "-- Initialize Yaskawa Robot monitoring\nprint('Yaskawa Robot connector initialized')\n-- Define robot status mappings\nRobotStates = {\n  [0] = 'Stopped',\n  [1] = 'Running',\n  [2] = 'Paused',\n  [3] = 'Error',\n  [4] = 'Teaching',\n  [5] = 'Play'\n}\n-- Define alarm severity mappings\nAlarmSeverity = {\n  [1] = 'Information',\n  [2] = 'Warning',\n  [3] = 'Minor',\n  [4] = 'Major',\n  [5] = 'Critical'\n}\n-- Position conversion factors\nMM_TO_INCHES = 0.0393701\nDEG_TO_RAD = math.pi / 180",
          "enter_script": "-- Log robot monitoring cycle\n-- print('Robot data collection cycle started')",
          "exit_script": "-- Calculate robot utilization and efficiency\nlocal isRunning = cache('./RobotRunning', false)\nlocal isInCycle = cache('./InCycle', false)\nlocal currentTime = os.time()\nlocal lastTime = cache('last_util_time', currentTime)\nlocal runTime = cache('total_run_time', 0)\nlocal cycleTime = cache('total_cycle_time', 0)\n-- Update run time\nif isRunning and currentTime > lastTime then\n  local deltaTime = currentTime - lastTime\n  runTime = runTime + deltaTime\n  set('total_run_time', runTime)\n  if isInCycle then\n    cycleTime = cycleTime + deltaTime\n    set('total_cycle_time', cycleTime)\n  end\nend\nset('last_util_time', currentTime)\n-- Calculate utilization over last hour\nlocal utilization = (runTime / 3600) * 100\nlocal cycleEfficiency = runTime > 0 and (cycleTime / runTime * 100) or 0\nif utilization <= 100 then\n  emit('./Utilization', math.floor(utilization * 10) / 10)\nend\nif cycleEfficiency <= 100 then\n  emit('./CycleEfficiency', math.floor(cycleEfficiency * 10) / 10)\nend",
          "items": [
            {
              "name": "Availability",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 1,
              "script": "-- Calculate robot availability\nlocal isConnected = cache('./$SYSTEM/IsConnected', false)\nlocal hasAlarm = cache('./AlarmActive', false)\nlocal servoOn = cache('./ServoOn', false)\nif not isConnected then\n  return 'Unavailable'\nelseif hasAlarm then\n  return 'Fault'\nelseif not servoOn then\n  return 'Servo_Off'\nelse\n  return 'Available'\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Availability[category=Event]"
              }
            },
            {
              "name": "CartesianPositionX",
              "enabled": true,
              "address": "cartesianPositions.X",
              "rbe": true,
              "every": 1,
              "script": "-- X-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -3000 and pos <= 3000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/XPosition[category=Sample]"
              }
            },
            {
              "name": "CartesianPositionY",
              "enabled": true,
              "address": "cartesianPositions.Y",
              "rbe": true,
              "every": 1,
              "script": "-- Y-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -3000 and pos <= 3000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/YPosition[category=Sample]"
              }
            },
            {
              "name": "CartesianPositionZ",
              "enabled": true,
              "address": "cartesianPositions.Z",
              "rbe": true,
              "every": 1,
              "script": "-- Z-axis position in millimeters\nlocal pos = tonumber(result)\nif pos and pos >= -1000 and pos <= 2000 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Path/ZPosition[category=Sample]"
              }
            },
            {
              "name": "CartesianRotationRx",
              "enabled": true,
              "address": "cartesianPositions.Rx",
              "rbe": true,
              "every": 2,
              "script": "-- Rx rotation in degrees\nlocal rot = tonumber(result)\nif rot and rot >= -180 and rot <= 180 then\n  return math.floor(rot * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "CartesianRotationRy",
              "enabled": true,
              "address": "cartesianPositions.Ry",
              "rbe": true,
              "every": 2,
              "script": "-- Ry rotation in degrees\nlocal rot = tonumber(result)\nif rot and rot >= -180 and rot <= 180 then\n  return math.floor(rot * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "CartesianRotationRz",
              "enabled": true,
              "address": "cartesianPositions.Rz",
              "rbe": true,
              "every": 2,
              "script": "-- Rz rotation in degrees\nlocal rot = tonumber(result)\nif rot and rot >= -180 and rot <= 180 then\n  return math.floor(rot * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition1",
              "enabled": true,
              "address": "jointPositions.Axis1",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 1 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition2",
              "enabled": true,
              "address": "jointPositions.Axis2",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 2 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition3",
              "enabled": true,
              "address": "jointPositions.Axis3",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 3 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition4",
              "enabled": true,
              "address": "jointPositions.Axis4",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 4 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition5",
              "enabled": true,
              "address": "jointPositions.Axis5",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 5 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "JointPosition6",
              "enabled": true,
              "address": "jointPositions.Axis6",
              "rbe": true,
              "every": 2,
              "script": "-- Joint 6 position in degrees\nlocal pos = tonumber(result)\nif pos and pos >= -180 and pos <= 180 then\n  return math.floor(pos * 100) / 100\nelse\n  return nil\nend"
            },
            {
              "name": "RobotRunning",
              "enabled": true,
              "address": "status.Running",
              "rbe": true,
              "every": 1,
              "script": "-- Robot running status\nlocal running = result == true or result == 1\nreturn running",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Execution[category=Event]"
              }
            },
            {
              "name": "InCycle",
              "enabled": true,
              "address": "status.Cycle",
              "rbe": true,
              "every": 1,
              "script": "-- Robot in cycle status\nlocal inCycle = result == true or result == 1\nreturn inCycle"
            },
            {
              "name": "AutomaticMode",
              "enabled": true,
              "address": "status.Automatic",
              "rbe": true,
              "every": 2,
              "script": "-- Automatic mode status\nlocal autoMode = result == true or result == 1\nreturn autoMode and 'Automatic' or 'Manual'"
            },
            {
              "name": "TeachMode",
              "enabled": true,
              "address": "status.Teach",
              "rbe": true,
              "every": 2,
              "script": "-- Teach mode status\nlocal teachMode = result == true or result == 1\nreturn teachMode and 'Teaching' or 'Playing'"
            },
            {
              "name": "PlayMode",
              "enabled": true,
              "address": "status.Play",
              "rbe": true,
              "every": 2,
              "script": "-- Play mode status\nlocal playMode = result == true or result == 1\nreturn playMode and 'Play' or 'Pause'"
            },
            {
              "name": "ServoOn",
              "enabled": true,
              "address": "status.ServoOn",
              "rbe": true,
              "every": 1,
              "script": "-- Servo power status\nlocal servoOn = result == true or result == 1\nreturn servoOn"
            },
            {
              "name": "AlarmActive",
              "enabled": true,
              "address": "status.Alarming",
              "rbe": true,
              "every": 1,
              "script": "-- Alarm status\nlocal alarming = result == true or result == 1\nreturn alarming"
            },
            {
              "name": "ErrorOccurring",
              "enabled": true,
              "address": "status.ErrorOccurring",
              "rbe": true,
              "every": 1,
              "script": "-- Error status\nlocal errorOccurring = result == true or result == 1\nreturn errorOccurring"
            },
            {
              "name": "InGuardSafeOperation",
              "enabled": true,
              "address": "status.InGuardSafeOperation",
              "rbe": true,
              "every": 1,
              "script": "-- Safety guard status\nlocal safeOp = result == true or result == 1\nreturn safeOp and 'Safe' or 'Unsafe'"
            },
            {
              "name": "CommandRemote",
              "enabled": true,
              "address": "status.CommandRemote",
              "rbe": true,
              "every": 2,
              "script": "-- Remote command status\nlocal remote = result == true or result == 1\nreturn remote and 'Remote' or 'Local'"
            },
            {
              "name": "HoldStatusPendant",
              "enabled": true,
              "address": "status.InHoldStatusPendant",
              "rbe": true,
              "every": 1,
              "script": "-- Pendant hold status\nlocal hold = result == true or result == 1\nreturn hold and 'Hold_Active' or 'Hold_Inactive'"
            },
            {
              "name": "HoldStatusExternal",
              "enabled": true,
              "address": "status.InHoldStatusExternally",
              "rbe": true,
              "every": 1,
              "script": "-- External hold status\nlocal hold = result == true or result == 1\nreturn hold and 'External_Hold' or 'Normal'"
            },
            {
              "name": "HoldStatusCommand",
              "enabled": true,
              "address": "status.InHoldStatusByCommand",
              "rbe": true,
              "every": 1,
              "script": "-- Command hold status\nlocal hold = result == true or result == 1\nreturn hold and 'Command_Hold' or 'Normal'"
            },
            {
              "name": "CurrentStep",
              "enabled": true,
              "address": "status.Step",
              "rbe": true,
              "every": 2,
              "script": "-- Current program step\nlocal step = tonumber(result)\nif step and step >= 0 and step <= 9999 then\n  return step\nelse\n  return 0\nend"
            },
            {
              "name": "JobName",
              "enabled": true,
              "address": "job.Name",
              "rbe": true,
              "every": 3,
              "script": "-- Current job/program name\nlocal jobName = tostring(result or '')\njobName = string.gsub(jobName, '^%s*(.-)%s*$', '%1')\nreturn jobName ~= '' and jobName or 'No_Job'",
              "sink": {
                "mtconnect": "Device[name=robot1]/Controller/Program[category=Event]"
              }
            },
            {
              "name": "JobLine",
              "enabled": true,
              "address": "job.Line",
              "rbe": true,
              "every": 2,
              "script": "-- Current job line number\nlocal line = tonumber(result)\nif line and line >= 0 then\n  return line\nelse\n  return 0\nend"
            },
            {
              "name": "JobStep",
              "enabled": true,
              "address": "job.Step",
              "rbe": true,
              "every": 2,
              "script": "-- Current job step number\nlocal step = tonumber(result)\nif step and step >= 0 then\n  return step\nelse\n  return 0\nend"
            },
            {
              "name": "SpeedOverride",
              "enabled": true,
              "address": "job.SpeedOverride",
              "rbe": true,
              "every": 3,
              "script": "-- Speed override percentage\nlocal override = tonumber(result)\nif override and override >= 1 and override <= 300 then\n  return override\nelse\n  return 100\nend"
            },
            {
              "name": "AlarmCode",
              "enabled": true,
              "address": "alarm.Code",
              "rbe": true,
              "every": 1,
              "script": "-- Current alarm code\nlocal code = tonumber(result)\nif code and code > 0 then\n  return code\nelse\n  return 0\nend"
            },
            {
              "name": "AlarmData",
              "enabled": true,
              "address": "alarm.Data",
              "rbe": true,
              "every": 1,
              "script": "-- Alarm data/details\nlocal data = tonumber(result)\nreturn data or 0"
            },
            {
              "name": "AlarmType",
              "enabled": true,
              "address": "alarm.Type",
              "rbe": true,
              "every": 1,
              "script": "-- Alarm type/category\nlocal alarmType = tonumber(result)\nlocal types = {\n  [1] = 'System',\n  [2] = 'User',\n  [3] = 'Motion',\n  [4] = 'I/O',\n  [5] = 'Safety'\n}\nreturn types[alarmType] or 'Unknown'"
            },
            {
              "name": "AlarmText",
              "enabled": true,
              "address": "alarm.Text",
              "rbe": true,
              "every": 1,
              "script": "-- Alarm text message\nlocal text = tostring(result or '')\ntext = string.gsub(text, '^%s*(.-)%s*$', '%1')\nreturn text ~= '' and text or 'No_Message'"
            },
            {
              "name": "AlarmOccurringTime",
              "enabled": true,
              "address": "alarm.OccurringTime",
              "rbe": true,
              "every": 1,
              "script": "-- Alarm occurrence timestamp\nlocal timestamp = tonumber(result)\nif timestamp and timestamp > 0 then\n  return os.date('%Y-%m-%d %H:%M:%S', timestamp)\nelse\n  return 'No_Time'\nend"
            },
            {
              "name": "PositionError1",
              "enabled": true,
              "address": "positionError.Axis1",
              "rbe": true,
              "every": 3,
              "script": "-- Position error for axis 1\nlocal error = tonumber(result)\nif error and math.abs(error) <= 10 then\n  return math.floor(error * 1000) / 1000\nelse\n  return nil\nend"
            },
            {
              "name": "PositionError2",
              "enabled": true,
              "address": "positionError.Axis2",
              "rbe": true,
              "every": 3,
              "script": "-- Position error for axis 2\nlocal error = tonumber(result)\nif error and math.abs(error) <= 10 then\n  return math.floor(error * 1000) / 1000\nelse\n  return nil\nend"
            },
            {
              "name": "TorqueAxis1",
              "enabled": true,
              "address": "torque.Axis1",
              "rbe": true,
              "every": 2,
              "script": "-- Torque feedback for axis 1\nlocal torque = tonumber(result)\nif torque and torque >= -100 and torque <= 100 then\n  return math.floor(torque * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "TorqueAxis2",
              "enabled": true,
              "address": "torque.Axis2",
              "rbe": true,
              "every": 2,
              "script": "-- Torque feedback for axis 2\nlocal torque = tonumber(result)\nif torque and torque >= -100 and torque <= 100 then\n  return math.floor(torque * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "TorqueAxis3",
              "enabled": true,
              "address": "torque.Axis3",
              "rbe": true,
              "every": 2,
              "script": "-- Torque feedback for axis 3\nlocal torque = tonumber(result)\nif torque and torque >= -100 and torque <= 100 then\n  return math.floor(torque * 10) / 10\nelse\n  return nil\nend"
            },
            {
              "name": "CycleCount",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 5,
              "script": "-- Calculate cycle count based on job completion\nlocal currentStep = cache('./CurrentStep', 0)\nlocal lastStep = cache('last_step', 0)\nlocal cycleCount = cache('cycle_count', 0)\n-- Detect cycle completion (step reset to 1 or low value)\nif lastStep > 10 and currentStep <= 3 then\n  cycleCount = cycleCount + 1\n  set('cycle_count', cycleCount)\nend\nset('last_step', currentStep)\nreturn cycleCount"
            },
            {
              "name": "OverallEffectiveness",
              "enabled": true,
              "address": "~",
              "rbe": true,
              "every": 10,
              "script": "-- Calculate overall robot effectiveness\nlocal isRunning = cache('./RobotRunning', false)\nlocal hasAlarm = cache('./AlarmActive', false)\nlocal servoOn = cache('./ServoOn', false)\nlocal inCycle = cache('./InCycle', false)\n-- Calculate availability (0-100)\nlocal availability = 0\nif servoOn and not hasAlarm then\n  availability = 100\nend\n-- Calculate performance (0-100)\nlocal performance = 0\nif isRunning and inCycle then\n  performance = 100\nelseif isRunning then\n  performance = 50\nend\n-- Calculate quality (assume 100% unless errors)\nlocal quality = hasAlarm and 50 or 100\n-- Overall effectiveness\nlocal oee = (availability * performance * quality) / 1000000 * 100\nreturn math.floor(oee * 10) / 10"
            }
          ],
          "strip_path_prefix": false,
          "sink": {
            "transform": {
              "type": "script",
              "template": "Message.Data"
            }
          }
        }
      ]
    }
  }
}